"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkphoton_wasm"] = self["webpackChunkphoton_wasm"] || []).push([["crate_pkg_photon_rs_js"],{

/***/ "../crate/pkg/photon_rs.js":
/*!*********************************!*\
  !*** ../crate/pkg/photon_rs.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhotonImage: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.PhotonImage),\n/* harmony export */   Rgb: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.Rgb),\n/* harmony export */   Rgba: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.Rgba),\n/* harmony export */   SamplingFilter: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.SamplingFilter),\n/* harmony export */   __wbg_appendChild_173b88a25c048f2b: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_appendChild_173b88a25c048f2b),\n/* harmony export */   __wbg_body_483afe07b0958d3b: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_body_483afe07b0958d3b),\n/* harmony export */   __wbg_buffer_fcbfb6d88b2732e9: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_buffer_fcbfb6d88b2732e9),\n/* harmony export */   __wbg_call_f96b398515635514: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_f96b398515635514),\n/* harmony export */   __wbg_createElement_5281e2aae74efc9d: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_createElement_5281e2aae74efc9d),\n/* harmony export */   __wbg_data_f319d3380b214a26: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_data_f319d3380b214a26),\n/* harmony export */   __wbg_document_a11e2f345af07033: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_document_a11e2f345af07033),\n/* harmony export */   __wbg_drawImage_41f8e8a7fc2b0de3: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_drawImage_41f8e8a7fc2b0de3),\n/* harmony export */   __wbg_drawImage_fa7fd856fb164132: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_drawImage_fa7fd856fb164132),\n/* harmony export */   __wbg_error_f851667af71bcfc6: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_error_f851667af71bcfc6),\n/* harmony export */   __wbg_getContext_62ccb1aa0e6c8b86: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getContext_62ccb1aa0e6c8b86),\n/* harmony export */   __wbg_getImageData_956c421f9b7cdfe7: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getImageData_956c421f9b7cdfe7),\n/* harmony export */   __wbg_globalThis_d0957e302752547e: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_globalThis_d0957e302752547e),\n/* harmony export */   __wbg_global_ae2f87312b8987fb: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_global_ae2f87312b8987fb),\n/* harmony export */   __wbg_height_b7046017c4148386: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_height_b7046017c4148386),\n/* harmony export */   __wbg_height_d65d28af1b6f26d3: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_height_d65d28af1b6f26d3),\n/* harmony export */   __wbg_height_e41b71b2f3141e8e: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_height_e41b71b2f3141e8e),\n/* harmony export */   __wbg_instanceof_CanvasRenderingContext2d_b4050f3a451ac712: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_instanceof_CanvasRenderingContext2d_b4050f3a451ac712),\n/* harmony export */   __wbg_instanceof_HtmlCanvasElement_6e58598b4e8b1586: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_instanceof_HtmlCanvasElement_6e58598b4e8b1586),\n/* harmony export */   __wbg_instanceof_Window_f2bf9e8e91f1be0d: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_instanceof_Window_f2bf9e8e91f1be0d),\n/* harmony export */   __wbg_length_d9c4ded7e708c6a1: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_d9c4ded7e708c6a1),\n/* harmony export */   __wbg_new_abda76e883ba8a5f: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_abda76e883ba8a5f),\n/* harmony export */   __wbg_new_bc5d9aad3f9ac80e: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_bc5d9aad3f9ac80e),\n/* harmony export */   __wbg_newnoargs_e643855c6572a4a8: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newnoargs_e643855c6572a4a8),\n/* harmony export */   __wbg_newwithu8clampedarrayandsh_c90e0c3609c4ecc2: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithu8clampedarrayandsh_c90e0c3609c4ecc2),\n/* harmony export */   __wbg_putImageData_0009acf77045dec6: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_putImageData_0009acf77045dec6),\n/* harmony export */   __wbg_random_f67f027fd89c6d9c: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_random_f67f027fd89c6d9c),\n/* harmony export */   __wbg_self_b9aad7f1c618bfaf: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_self_b9aad7f1c618bfaf),\n/* harmony export */   __wbg_set_4b3aa8445ac1e91c: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_4b3aa8445ac1e91c),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   __wbg_setheight_0d2b445bb6a5a3f2: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setheight_0d2b445bb6a5a3f2),\n/* harmony export */   __wbg_settextContent_ea2ce5e8fc889af7: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_settextContent_ea2ce5e8fc889af7),\n/* harmony export */   __wbg_setwidth_885d5dd3c7f48f41: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setwidth_885d5dd3c7f48f41),\n/* harmony export */   __wbg_stack_658279fe44541cf6: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_stack_658279fe44541cf6),\n/* harmony export */   __wbg_width_020d7bde350571e9: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_width_020d7bde350571e9),\n/* harmony export */   __wbg_width_250e8da00ab1c884: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_width_250e8da00ab1c884),\n/* harmony export */   __wbg_width_3a395887a577233b: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_width_3a395887a577233b),\n/* harmony export */   __wbg_window_55e469842c98b086: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_window_55e469842c98b086),\n/* harmony export */   __wbindgen_debug_string: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_debug_string),\n/* harmony export */   __wbindgen_is_undefined: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_undefined),\n/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_memory),\n/* harmony export */   __wbindgen_object_clone_ref: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_clone_ref),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),\n/* harmony export */   add_noise_rand: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.add_noise_rand),\n/* harmony export */   adjust_contrast: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.adjust_contrast),\n/* harmony export */   alter_blue_channel: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.alter_blue_channel),\n/* harmony export */   alter_channel: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.alter_channel),\n/* harmony export */   alter_channels: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.alter_channels),\n/* harmony export */   alter_green_channel: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.alter_green_channel),\n/* harmony export */   alter_red_channel: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.alter_red_channel),\n/* harmony export */   alter_two_channels: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.alter_two_channels),\n/* harmony export */   apply_gradient: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.apply_gradient),\n/* harmony export */   b_grayscale: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.b_grayscale),\n/* harmony export */   base64_to_image: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.base64_to_image),\n/* harmony export */   base64_to_vec: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.base64_to_vec),\n/* harmony export */   blend: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.blend),\n/* harmony export */   box_blur: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.box_blur),\n/* harmony export */   cali: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.cali),\n/* harmony export */   color_horizontal_strips: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.color_horizontal_strips),\n/* harmony export */   color_vertical_strips: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.color_vertical_strips),\n/* harmony export */   colorize: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.colorize),\n/* harmony export */   create_gradient: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.create_gradient),\n/* harmony export */   crop: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.crop),\n/* harmony export */   crop_img_browser: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.crop_img_browser),\n/* harmony export */   darken_hsl: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.darken_hsl),\n/* harmony export */   darken_hsluv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.darken_hsluv),\n/* harmony export */   darken_hsv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.darken_hsv),\n/* harmony export */   darken_lch: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.darken_lch),\n/* harmony export */   decompose_max: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.decompose_max),\n/* harmony export */   decompose_min: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.decompose_min),\n/* harmony export */   desaturate: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.desaturate),\n/* harmony export */   desaturate_hsl: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.desaturate_hsl),\n/* harmony export */   desaturate_hsluv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.desaturate_hsluv),\n/* harmony export */   desaturate_hsv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.desaturate_hsv),\n/* harmony export */   desaturate_lch: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.desaturate_lch),\n/* harmony export */   detect_135_deg_lines: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.detect_135_deg_lines),\n/* harmony export */   detect_45_deg_lines: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.detect_45_deg_lines),\n/* harmony export */   detect_horizontal_lines: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.detect_horizontal_lines),\n/* harmony export */   detect_vertical_lines: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.detect_vertical_lines),\n/* harmony export */   dither: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.dither),\n/* harmony export */   dramatic: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.dramatic),\n/* harmony export */   draw_text: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.draw_text),\n/* harmony export */   draw_text_with_border: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.draw_text_with_border),\n/* harmony export */   duotone: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.duotone),\n/* harmony export */   duotone_horizon: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.duotone_horizon),\n/* harmony export */   duotone_lilac: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.duotone_lilac),\n/* harmony export */   duotone_ochre: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.duotone_ochre),\n/* harmony export */   duotone_tint: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.duotone_tint),\n/* harmony export */   duotone_violette: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.duotone_violette),\n/* harmony export */   edge_detection: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.edge_detection),\n/* harmony export */   edge_one: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.edge_one),\n/* harmony export */   emboss: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.emboss),\n/* harmony export */   filter: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.filter),\n/* harmony export */   firenze: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.firenze),\n/* harmony export */   fliph: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.fliph),\n/* harmony export */   flipv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.flipv),\n/* harmony export */   frosted_glass: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.frosted_glass),\n/* harmony export */   g_grayscale: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.g_grayscale),\n/* harmony export */   gamma_correction: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.gamma_correction),\n/* harmony export */   gaussian_blur: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.gaussian_blur),\n/* harmony export */   get_image_data: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.get_image_data),\n/* harmony export */   golden: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.golden),\n/* harmony export */   grayscale: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.grayscale),\n/* harmony export */   grayscale_human_corrected: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.grayscale_human_corrected),\n/* harmony export */   grayscale_shades: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.grayscale_shades),\n/* harmony export */   horizontal_strips: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.horizontal_strips),\n/* harmony export */   hsl: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.hsl),\n/* harmony export */   hsluv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.hsluv),\n/* harmony export */   hsv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.hsv),\n/* harmony export */   hue_rotate_hsl: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.hue_rotate_hsl),\n/* harmony export */   hue_rotate_hsluv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.hue_rotate_hsluv),\n/* harmony export */   hue_rotate_hsv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.hue_rotate_hsv),\n/* harmony export */   hue_rotate_lch: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.hue_rotate_lch),\n/* harmony export */   identity: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.identity),\n/* harmony export */   inc_brightness: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.inc_brightness),\n/* harmony export */   invert: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.invert),\n/* harmony export */   laplace: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.laplace),\n/* harmony export */   lch: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.lch),\n/* harmony export */   lighten_hsl: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.lighten_hsl),\n/* harmony export */   lighten_hsluv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.lighten_hsluv),\n/* harmony export */   lighten_hsv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.lighten_hsv),\n/* harmony export */   lighten_lch: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.lighten_lch),\n/* harmony export */   lix: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.lix),\n/* harmony export */   lofi: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.lofi),\n/* harmony export */   median: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.median),\n/* harmony export */   mix_with_colour: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.mix_with_colour),\n/* harmony export */   monochrome: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.monochrome),\n/* harmony export */   monochrome_tint: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.monochrome_tint),\n/* harmony export */   multiple_offsets: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.multiple_offsets),\n/* harmony export */   neue: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.neue),\n/* harmony export */   noise_reduction: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.noise_reduction),\n/* harmony export */   normalize: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.normalize),\n/* harmony export */   obsidian: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.obsidian),\n/* harmony export */   offset: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   offset_blue: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.offset_blue),\n/* harmony export */   offset_green: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.offset_green),\n/* harmony export */   offset_red: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.offset_red),\n/* harmony export */   oil: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.oil),\n/* harmony export */   open_image: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.open_image),\n/* harmony export */   padding_bottom: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.padding_bottom),\n/* harmony export */   padding_left: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.padding_left),\n/* harmony export */   padding_right: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.padding_right),\n/* harmony export */   padding_top: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.padding_top),\n/* harmony export */   padding_uniform: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.padding_uniform),\n/* harmony export */   pastel_pink: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.pastel_pink),\n/* harmony export */   pink_noise: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.pink_noise),\n/* harmony export */   pixelize: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.pixelize),\n/* harmony export */   prewitt_horizontal: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.prewitt_horizontal),\n/* harmony export */   primary: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.primary),\n/* harmony export */   putImageData: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.putImageData),\n/* harmony export */   r_grayscale: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.r_grayscale),\n/* harmony export */   remove_blue_channel: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.remove_blue_channel),\n/* harmony export */   remove_channel: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.remove_channel),\n/* harmony export */   remove_green_channel: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.remove_green_channel),\n/* harmony export */   remove_red_channel: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.remove_red_channel),\n/* harmony export */   resample: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.resample),\n/* harmony export */   resize: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.resize),\n/* harmony export */   resize_img_browser: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.resize_img_browser),\n/* harmony export */   rotate: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.rotate),\n/* harmony export */   run: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.run),\n/* harmony export */   ryo: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.ryo),\n/* harmony export */   saturate_hsl: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.saturate_hsl),\n/* harmony export */   saturate_hsluv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.saturate_hsluv),\n/* harmony export */   saturate_hsv: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.saturate_hsv),\n/* harmony export */   saturate_lch: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.saturate_lch),\n/* harmony export */   seam_carve: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.seam_carve),\n/* harmony export */   selective_color_convert: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.selective_color_convert),\n/* harmony export */   selective_desaturate: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.selective_desaturate),\n/* harmony export */   selective_greyscale: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.selective_greyscale),\n/* harmony export */   selective_hue_rotate: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.selective_hue_rotate),\n/* harmony export */   selective_lighten: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.selective_lighten),\n/* harmony export */   selective_saturate: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.selective_saturate),\n/* harmony export */   sepia: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.sepia),\n/* harmony export */   sharpen: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.sharpen),\n/* harmony export */   single_channel_grayscale: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.single_channel_grayscale),\n/* harmony export */   sobel_horizontal: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.sobel_horizontal),\n/* harmony export */   sobel_vertical: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.sobel_vertical),\n/* harmony export */   solarize: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.solarize),\n/* harmony export */   solarize_retimg: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.solarize_retimg),\n/* harmony export */   swap_channels: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.swap_channels),\n/* harmony export */   threshold: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.threshold),\n/* harmony export */   tint: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.tint),\n/* harmony export */   to_image_data: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.to_image_data),\n/* harmony export */   to_raw_pixels: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.to_raw_pixels),\n/* harmony export */   vertical_strips: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.vertical_strips),\n/* harmony export */   watermark: () => (/* reexport safe */ _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.watermark)\n/* harmony export */ });\n/* harmony import */ var _photon_rs_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./photon_rs_bg.wasm */ \"../crate/pkg/photon_rs_bg.wasm\");\n/* harmony import */ var _photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./photon_rs_bg.js */ \"../crate/pkg/photon_rs_bg.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_photon_rs_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);\n_photon_rs_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n(0,_photon_rs_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm)(_photon_rs_bg_wasm__WEBPACK_IMPORTED_MODULE_1__);\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://photon-wasm/../crate/pkg/photon_rs.js?");

/***/ }),

/***/ "../crate/pkg/photon_rs_bg.js":
/*!************************************!*\
  !*** ../crate/pkg/photon_rs_bg.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhotonImage: () => (/* binding */ PhotonImage),\n/* harmony export */   Rgb: () => (/* binding */ Rgb),\n/* harmony export */   Rgba: () => (/* binding */ Rgba),\n/* harmony export */   SamplingFilter: () => (/* binding */ SamplingFilter),\n/* harmony export */   __wbg_appendChild_173b88a25c048f2b: () => (/* binding */ __wbg_appendChild_173b88a25c048f2b),\n/* harmony export */   __wbg_body_483afe07b0958d3b: () => (/* binding */ __wbg_body_483afe07b0958d3b),\n/* harmony export */   __wbg_buffer_fcbfb6d88b2732e9: () => (/* binding */ __wbg_buffer_fcbfb6d88b2732e9),\n/* harmony export */   __wbg_call_f96b398515635514: () => (/* binding */ __wbg_call_f96b398515635514),\n/* harmony export */   __wbg_createElement_5281e2aae74efc9d: () => (/* binding */ __wbg_createElement_5281e2aae74efc9d),\n/* harmony export */   __wbg_data_f319d3380b214a26: () => (/* binding */ __wbg_data_f319d3380b214a26),\n/* harmony export */   __wbg_document_a11e2f345af07033: () => (/* binding */ __wbg_document_a11e2f345af07033),\n/* harmony export */   __wbg_drawImage_41f8e8a7fc2b0de3: () => (/* binding */ __wbg_drawImage_41f8e8a7fc2b0de3),\n/* harmony export */   __wbg_drawImage_fa7fd856fb164132: () => (/* binding */ __wbg_drawImage_fa7fd856fb164132),\n/* harmony export */   __wbg_error_f851667af71bcfc6: () => (/* binding */ __wbg_error_f851667af71bcfc6),\n/* harmony export */   __wbg_getContext_62ccb1aa0e6c8b86: () => (/* binding */ __wbg_getContext_62ccb1aa0e6c8b86),\n/* harmony export */   __wbg_getImageData_956c421f9b7cdfe7: () => (/* binding */ __wbg_getImageData_956c421f9b7cdfe7),\n/* harmony export */   __wbg_globalThis_d0957e302752547e: () => (/* binding */ __wbg_globalThis_d0957e302752547e),\n/* harmony export */   __wbg_global_ae2f87312b8987fb: () => (/* binding */ __wbg_global_ae2f87312b8987fb),\n/* harmony export */   __wbg_height_b7046017c4148386: () => (/* binding */ __wbg_height_b7046017c4148386),\n/* harmony export */   __wbg_height_d65d28af1b6f26d3: () => (/* binding */ __wbg_height_d65d28af1b6f26d3),\n/* harmony export */   __wbg_height_e41b71b2f3141e8e: () => (/* binding */ __wbg_height_e41b71b2f3141e8e),\n/* harmony export */   __wbg_instanceof_CanvasRenderingContext2d_b4050f3a451ac712: () => (/* binding */ __wbg_instanceof_CanvasRenderingContext2d_b4050f3a451ac712),\n/* harmony export */   __wbg_instanceof_HtmlCanvasElement_6e58598b4e8b1586: () => (/* binding */ __wbg_instanceof_HtmlCanvasElement_6e58598b4e8b1586),\n/* harmony export */   __wbg_instanceof_Window_f2bf9e8e91f1be0d: () => (/* binding */ __wbg_instanceof_Window_f2bf9e8e91f1be0d),\n/* harmony export */   __wbg_length_d9c4ded7e708c6a1: () => (/* binding */ __wbg_length_d9c4ded7e708c6a1),\n/* harmony export */   __wbg_new_abda76e883ba8a5f: () => (/* binding */ __wbg_new_abda76e883ba8a5f),\n/* harmony export */   __wbg_new_bc5d9aad3f9ac80e: () => (/* binding */ __wbg_new_bc5d9aad3f9ac80e),\n/* harmony export */   __wbg_newnoargs_e643855c6572a4a8: () => (/* binding */ __wbg_newnoargs_e643855c6572a4a8),\n/* harmony export */   __wbg_newwithu8clampedarrayandsh_c90e0c3609c4ecc2: () => (/* binding */ __wbg_newwithu8clampedarrayandsh_c90e0c3609c4ecc2),\n/* harmony export */   __wbg_putImageData_0009acf77045dec6: () => (/* binding */ __wbg_putImageData_0009acf77045dec6),\n/* harmony export */   __wbg_random_f67f027fd89c6d9c: () => (/* binding */ __wbg_random_f67f027fd89c6d9c),\n/* harmony export */   __wbg_self_b9aad7f1c618bfaf: () => (/* binding */ __wbg_self_b9aad7f1c618bfaf),\n/* harmony export */   __wbg_set_4b3aa8445ac1e91c: () => (/* binding */ __wbg_set_4b3aa8445ac1e91c),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbg_setheight_0d2b445bb6a5a3f2: () => (/* binding */ __wbg_setheight_0d2b445bb6a5a3f2),\n/* harmony export */   __wbg_settextContent_ea2ce5e8fc889af7: () => (/* binding */ __wbg_settextContent_ea2ce5e8fc889af7),\n/* harmony export */   __wbg_setwidth_885d5dd3c7f48f41: () => (/* binding */ __wbg_setwidth_885d5dd3c7f48f41),\n/* harmony export */   __wbg_stack_658279fe44541cf6: () => (/* binding */ __wbg_stack_658279fe44541cf6),\n/* harmony export */   __wbg_width_020d7bde350571e9: () => (/* binding */ __wbg_width_020d7bde350571e9),\n/* harmony export */   __wbg_width_250e8da00ab1c884: () => (/* binding */ __wbg_width_250e8da00ab1c884),\n/* harmony export */   __wbg_width_3a395887a577233b: () => (/* binding */ __wbg_width_3a395887a577233b),\n/* harmony export */   __wbg_window_55e469842c98b086: () => (/* binding */ __wbg_window_55e469842c98b086),\n/* harmony export */   __wbindgen_debug_string: () => (/* binding */ __wbindgen_debug_string),\n/* harmony export */   __wbindgen_is_undefined: () => (/* binding */ __wbindgen_is_undefined),\n/* harmony export */   __wbindgen_memory: () => (/* binding */ __wbindgen_memory),\n/* harmony export */   __wbindgen_object_clone_ref: () => (/* binding */ __wbindgen_object_clone_ref),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* binding */ __wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw),\n/* harmony export */   add_noise_rand: () => (/* binding */ add_noise_rand),\n/* harmony export */   adjust_contrast: () => (/* binding */ adjust_contrast),\n/* harmony export */   alter_blue_channel: () => (/* binding */ alter_blue_channel),\n/* harmony export */   alter_channel: () => (/* binding */ alter_channel),\n/* harmony export */   alter_channels: () => (/* binding */ alter_channels),\n/* harmony export */   alter_green_channel: () => (/* binding */ alter_green_channel),\n/* harmony export */   alter_red_channel: () => (/* binding */ alter_red_channel),\n/* harmony export */   alter_two_channels: () => (/* binding */ alter_two_channels),\n/* harmony export */   apply_gradient: () => (/* binding */ apply_gradient),\n/* harmony export */   b_grayscale: () => (/* binding */ b_grayscale),\n/* harmony export */   base64_to_image: () => (/* binding */ base64_to_image),\n/* harmony export */   base64_to_vec: () => (/* binding */ base64_to_vec),\n/* harmony export */   blend: () => (/* binding */ blend),\n/* harmony export */   box_blur: () => (/* binding */ box_blur),\n/* harmony export */   cali: () => (/* binding */ cali),\n/* harmony export */   color_horizontal_strips: () => (/* binding */ color_horizontal_strips),\n/* harmony export */   color_vertical_strips: () => (/* binding */ color_vertical_strips),\n/* harmony export */   colorize: () => (/* binding */ colorize),\n/* harmony export */   create_gradient: () => (/* binding */ create_gradient),\n/* harmony export */   crop: () => (/* binding */ crop),\n/* harmony export */   crop_img_browser: () => (/* binding */ crop_img_browser),\n/* harmony export */   darken_hsl: () => (/* binding */ darken_hsl),\n/* harmony export */   darken_hsluv: () => (/* binding */ darken_hsluv),\n/* harmony export */   darken_hsv: () => (/* binding */ darken_hsv),\n/* harmony export */   darken_lch: () => (/* binding */ darken_lch),\n/* harmony export */   decompose_max: () => (/* binding */ decompose_max),\n/* harmony export */   decompose_min: () => (/* binding */ decompose_min),\n/* harmony export */   desaturate: () => (/* binding */ desaturate),\n/* harmony export */   desaturate_hsl: () => (/* binding */ desaturate_hsl),\n/* harmony export */   desaturate_hsluv: () => (/* binding */ desaturate_hsluv),\n/* harmony export */   desaturate_hsv: () => (/* binding */ desaturate_hsv),\n/* harmony export */   desaturate_lch: () => (/* binding */ desaturate_lch),\n/* harmony export */   detect_135_deg_lines: () => (/* binding */ detect_135_deg_lines),\n/* harmony export */   detect_45_deg_lines: () => (/* binding */ detect_45_deg_lines),\n/* harmony export */   detect_horizontal_lines: () => (/* binding */ detect_horizontal_lines),\n/* harmony export */   detect_vertical_lines: () => (/* binding */ detect_vertical_lines),\n/* harmony export */   dither: () => (/* binding */ dither),\n/* harmony export */   dramatic: () => (/* binding */ dramatic),\n/* harmony export */   draw_text: () => (/* binding */ draw_text),\n/* harmony export */   draw_text_with_border: () => (/* binding */ draw_text_with_border),\n/* harmony export */   duotone: () => (/* binding */ duotone),\n/* harmony export */   duotone_horizon: () => (/* binding */ duotone_horizon),\n/* harmony export */   duotone_lilac: () => (/* binding */ duotone_lilac),\n/* harmony export */   duotone_ochre: () => (/* binding */ duotone_ochre),\n/* harmony export */   duotone_tint: () => (/* binding */ duotone_tint),\n/* harmony export */   duotone_violette: () => (/* binding */ duotone_violette),\n/* harmony export */   edge_detection: () => (/* binding */ edge_detection),\n/* harmony export */   edge_one: () => (/* binding */ edge_one),\n/* harmony export */   emboss: () => (/* binding */ emboss),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   firenze: () => (/* binding */ firenze),\n/* harmony export */   fliph: () => (/* binding */ fliph),\n/* harmony export */   flipv: () => (/* binding */ flipv),\n/* harmony export */   frosted_glass: () => (/* binding */ frosted_glass),\n/* harmony export */   g_grayscale: () => (/* binding */ g_grayscale),\n/* harmony export */   gamma_correction: () => (/* binding */ gamma_correction),\n/* harmony export */   gaussian_blur: () => (/* binding */ gaussian_blur),\n/* harmony export */   get_image_data: () => (/* binding */ get_image_data),\n/* harmony export */   golden: () => (/* binding */ golden),\n/* harmony export */   grayscale: () => (/* binding */ grayscale),\n/* harmony export */   grayscale_human_corrected: () => (/* binding */ grayscale_human_corrected),\n/* harmony export */   grayscale_shades: () => (/* binding */ grayscale_shades),\n/* harmony export */   horizontal_strips: () => (/* binding */ horizontal_strips),\n/* harmony export */   hsl: () => (/* binding */ hsl),\n/* harmony export */   hsluv: () => (/* binding */ hsluv),\n/* harmony export */   hsv: () => (/* binding */ hsv),\n/* harmony export */   hue_rotate_hsl: () => (/* binding */ hue_rotate_hsl),\n/* harmony export */   hue_rotate_hsluv: () => (/* binding */ hue_rotate_hsluv),\n/* harmony export */   hue_rotate_hsv: () => (/* binding */ hue_rotate_hsv),\n/* harmony export */   hue_rotate_lch: () => (/* binding */ hue_rotate_lch),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   inc_brightness: () => (/* binding */ inc_brightness),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   laplace: () => (/* binding */ laplace),\n/* harmony export */   lch: () => (/* binding */ lch),\n/* harmony export */   lighten_hsl: () => (/* binding */ lighten_hsl),\n/* harmony export */   lighten_hsluv: () => (/* binding */ lighten_hsluv),\n/* harmony export */   lighten_hsv: () => (/* binding */ lighten_hsv),\n/* harmony export */   lighten_lch: () => (/* binding */ lighten_lch),\n/* harmony export */   lix: () => (/* binding */ lix),\n/* harmony export */   lofi: () => (/* binding */ lofi),\n/* harmony export */   median: () => (/* binding */ median),\n/* harmony export */   mix_with_colour: () => (/* binding */ mix_with_colour),\n/* harmony export */   monochrome: () => (/* binding */ monochrome),\n/* harmony export */   monochrome_tint: () => (/* binding */ monochrome_tint),\n/* harmony export */   multiple_offsets: () => (/* binding */ multiple_offsets),\n/* harmony export */   neue: () => (/* binding */ neue),\n/* harmony export */   noise_reduction: () => (/* binding */ noise_reduction),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   obsidian: () => (/* binding */ obsidian),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   offset_blue: () => (/* binding */ offset_blue),\n/* harmony export */   offset_green: () => (/* binding */ offset_green),\n/* harmony export */   offset_red: () => (/* binding */ offset_red),\n/* harmony export */   oil: () => (/* binding */ oil),\n/* harmony export */   open_image: () => (/* binding */ open_image),\n/* harmony export */   padding_bottom: () => (/* binding */ padding_bottom),\n/* harmony export */   padding_left: () => (/* binding */ padding_left),\n/* harmony export */   padding_right: () => (/* binding */ padding_right),\n/* harmony export */   padding_top: () => (/* binding */ padding_top),\n/* harmony export */   padding_uniform: () => (/* binding */ padding_uniform),\n/* harmony export */   pastel_pink: () => (/* binding */ pastel_pink),\n/* harmony export */   pink_noise: () => (/* binding */ pink_noise),\n/* harmony export */   pixelize: () => (/* binding */ pixelize),\n/* harmony export */   prewitt_horizontal: () => (/* binding */ prewitt_horizontal),\n/* harmony export */   primary: () => (/* binding */ primary),\n/* harmony export */   putImageData: () => (/* binding */ putImageData),\n/* harmony export */   r_grayscale: () => (/* binding */ r_grayscale),\n/* harmony export */   remove_blue_channel: () => (/* binding */ remove_blue_channel),\n/* harmony export */   remove_channel: () => (/* binding */ remove_channel),\n/* harmony export */   remove_green_channel: () => (/* binding */ remove_green_channel),\n/* harmony export */   remove_red_channel: () => (/* binding */ remove_red_channel),\n/* harmony export */   resample: () => (/* binding */ resample),\n/* harmony export */   resize: () => (/* binding */ resize),\n/* harmony export */   resize_img_browser: () => (/* binding */ resize_img_browser),\n/* harmony export */   rotate: () => (/* binding */ rotate),\n/* harmony export */   run: () => (/* binding */ run),\n/* harmony export */   ryo: () => (/* binding */ ryo),\n/* harmony export */   saturate_hsl: () => (/* binding */ saturate_hsl),\n/* harmony export */   saturate_hsluv: () => (/* binding */ saturate_hsluv),\n/* harmony export */   saturate_hsv: () => (/* binding */ saturate_hsv),\n/* harmony export */   saturate_lch: () => (/* binding */ saturate_lch),\n/* harmony export */   seam_carve: () => (/* binding */ seam_carve),\n/* harmony export */   selective_color_convert: () => (/* binding */ selective_color_convert),\n/* harmony export */   selective_desaturate: () => (/* binding */ selective_desaturate),\n/* harmony export */   selective_greyscale: () => (/* binding */ selective_greyscale),\n/* harmony export */   selective_hue_rotate: () => (/* binding */ selective_hue_rotate),\n/* harmony export */   selective_lighten: () => (/* binding */ selective_lighten),\n/* harmony export */   selective_saturate: () => (/* binding */ selective_saturate),\n/* harmony export */   sepia: () => (/* binding */ sepia),\n/* harmony export */   sharpen: () => (/* binding */ sharpen),\n/* harmony export */   single_channel_grayscale: () => (/* binding */ single_channel_grayscale),\n/* harmony export */   sobel_horizontal: () => (/* binding */ sobel_horizontal),\n/* harmony export */   sobel_vertical: () => (/* binding */ sobel_vertical),\n/* harmony export */   solarize: () => (/* binding */ solarize),\n/* harmony export */   solarize_retimg: () => (/* binding */ solarize_retimg),\n/* harmony export */   swap_channels: () => (/* binding */ swap_channels),\n/* harmony export */   threshold: () => (/* binding */ threshold),\n/* harmony export */   tint: () => (/* binding */ tint),\n/* harmony export */   to_image_data: () => (/* binding */ to_image_data),\n/* harmony export */   to_raw_pixels: () => (/* binding */ to_raw_pixels),\n/* harmony export */   vertical_strips: () => (/* binding */ vertical_strips),\n/* harmony export */   watermark: () => (/* binding */ watermark)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction _assertBoolean(n) {\n    if (typeof(n) !== 'boolean') {\n        throw new Error('expected a boolean argument');\n    }\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    if (typeof(heap_next) !== 'number') throw new Error('corrupt heap');\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (typeof(arg) !== 'string') throw new Error('expected a string argument');\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n        if (ret.read !== arg.length) throw new Error('failed to pass whole string');\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction _assertNum(n) {\n    if (typeof(n) !== 'number') throw new Error('expected a number argument');\n}\n/**\n* Adds an offset to the image by a certain number of pixels.\n*\n* This creates an RGB shift effect.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `channel_index`: The index of the channel to increment. 0 for red, 1 for green and 2 for blue.\n* * `offset` - The offset is added to the pixels in the image.\n* # Example\n*\n* ```no_run\n* // For example, to offset pixels by 30 pixels on the red channel:\n* use photon_rs::effects::offset;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* offset(&mut img, 0_usize, 30_u32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel_index\n* @param {number} offset\n*/\nfunction offset(photon_image, channel_index, offset) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(channel_index);\n    _assertNum(offset);\n    wasm.offset(photon_image.__wbg_ptr, channel_index, offset);\n}\n\n/**\n* Adds an offset to the red channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset you want to move the red channel by.\n* # Example\n*\n* ```no_run\n* // For example, to add an offset to the red channel by 30 pixels.\n* use photon_rs::effects::offset_red;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* offset_red(&mut img, 30_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n*/\nfunction offset_red(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(offset_amt);\n    wasm.offset_red(img.__wbg_ptr, offset_amt);\n}\n\n/**\n* Adds an offset to the green channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset you want to move the green channel by.\n* # Example\n*\n* ```no_run\n* // For example, to add an offset to the green channel by 30 pixels.\n* use photon_rs::effects::offset_green;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* offset_green(&mut img, 30_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n*/\nfunction offset_green(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(offset_amt);\n    wasm.offset_green(img.__wbg_ptr, offset_amt);\n}\n\n/**\n* Adds an offset to the blue channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset_amt` - The offset you want to move the blue channel by.\n* # Example\n* // For example, to add an offset to the green channel by 40 pixels.\n*\n* ```no_run\n* use photon_rs::effects::offset_blue;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* offset_blue(&mut img, 40_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n*/\nfunction offset_blue(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(offset_amt);\n    wasm.offset_blue(img.__wbg_ptr, offset_amt);\n}\n\n/**\n* Adds multiple offsets to the image by a certain number of pixels (on two channels).\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset is added to the pixels in the image.\n* # Example\n*\n* ```no_run\n* // For example, to add a 30-pixel offset to both the red and blue channels:\n* use photon_rs::effects::multiple_offsets;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* multiple_offsets(&mut img, 30_u32, 0_usize, 2_usize);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} offset\n* @param {number} channel_index\n* @param {number} channel_index2\n*/\nfunction multiple_offsets(photon_image, offset, channel_index, channel_index2) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(offset);\n    _assertNum(channel_index);\n    _assertNum(channel_index2);\n    wasm.multiple_offsets(photon_image.__wbg_ptr, offset, channel_index, channel_index2);\n}\n\n/**\n* Reduces an image to the primary colours.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to add a primary colour effect to an image of type `DynamicImage`:\n* use photon_rs::effects::primary;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* primary(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction primary(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.primary(img.__wbg_ptr);\n}\n\n/**\n* Colorizes the green channels of the image.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to colorize an image of type `PhotonImage`:\n* use photon_rs::effects::colorize;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* colorize(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction colorize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.colorize(photon_image.__wbg_ptr);\n}\n\n/**\n* Applies a solarizing effect to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to colorize an image of type `PhotonImage`:\n* use photon_rs::effects::solarize;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* solarize(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction solarize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.solarize(photon_image.__wbg_ptr);\n}\n\n/**\n* Applies a solarizing effect to an image and returns the resulting PhotonImage.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to solarize \"retimg\" an image of type `PhotonImage`:\n* use photon_rs::effects::solarize_retimg;\n* use photon_rs::native::open_image;\n* use photon_rs::PhotonImage;\n*\n* let img = open_image(\"img.jpg\").expect(\"File should open\");\n* let result: PhotonImage = solarize_retimg(&img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nfunction solarize_retimg(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ret = wasm.solarize_retimg(photon_image.__wbg_ptr);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Increase the brightness of an image by a factor.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `brightness` - A u8 to add to the brightness.\n* # Example\n*\n* ```no_run\n* use photon_rs::effects::inc_brightness;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* inc_brightness(&mut img, 10_u8);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} brightness\n*/\nfunction inc_brightness(photon_image, brightness) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(brightness);\n    wasm.inc_brightness(photon_image.__wbg_ptr, brightness);\n}\n\n/**\n* Adjust the contrast of an image by a factor.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage that contains a view into the image.\n* * `contrast` - An f32 factor used to adjust contrast. Between [-255.0, 255.0]. The algorithm will\n* clamp results if passed factor is out of range.\n* # Example\n*\n* ```no_run\n* use photon_rs::effects::adjust_contrast;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* adjust_contrast(&mut img, 30_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} contrast\n*/\nfunction adjust_contrast(photon_image, contrast) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.adjust_contrast(photon_image.__wbg_ptr, contrast);\n}\n\n/**\n* Tint an image by adding an offset to averaged RGB channel values.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `r_offset` - The amount the R channel should be incremented by.\n* * `g_offset` - The amount the G channel should be incremented by.\n* * `b_offset` - The amount the B channel should be incremented by.\n* # Example\n*\n* ```no_run\n* // For example, to tint an image of type `PhotonImage`:\n* use photon_rs::effects::tint;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* tint(&mut img, 10_u32, 20_u32, 15_u32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n*/\nfunction tint(photon_image, r_offset, g_offset, b_offset) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(r_offset);\n    _assertNum(g_offset);\n    _assertNum(b_offset);\n    wasm.tint(photon_image.__wbg_ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n* Horizontal strips. Divide an image into a series of equal-height strips, for an artistic effect.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `num_strips` - The number of strips\n* # Example\n*\n* ```no_run\n* // For example, to draw horizontal strips on a `PhotonImage`:\n* use photon_rs::effects::horizontal_strips;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* horizontal_strips(&mut img, 8u8);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} num_strips\n*/\nfunction horizontal_strips(photon_image, num_strips) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(num_strips);\n    wasm.horizontal_strips(photon_image.__wbg_ptr, num_strips);\n}\n\n/**\n* Horizontal strips. Divide an image into a series of equal-width strips, for an artistic effect. Sepcify a color as well.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `num_strips` - The numbder of strips\n* * `color` - Color of strips.\n* # Example\n*\n* ```no_run\n* // For example, to draw blue horizontal strips on a `PhotonImage`:\n* use photon_rs::effects::color_horizontal_strips;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgb;\n*\n* let color = Rgb::new(255u8, 0u8, 0u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* color_horizontal_strips(&mut img, 8u8, color);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} num_strips\n* @param {Rgb} color\n*/\nfunction color_horizontal_strips(photon_image, num_strips, color) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(num_strips);\n    _assertClass(color, Rgb);\n    if (color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = color.__destroy_into_raw();\n    wasm.color_horizontal_strips(photon_image.__wbg_ptr, num_strips, ptr0);\n}\n\n/**\n* Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `num_strips` - The numbder of strips\n* # Example\n*\n* ```no_run\n* // For example, to draw vertical strips on a `PhotonImage`:\n* use photon_rs::effects::vertical_strips;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* vertical_strips(&mut img, 8u8);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} num_strips\n*/\nfunction vertical_strips(photon_image, num_strips) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(num_strips);\n    wasm.vertical_strips(photon_image.__wbg_ptr, num_strips);\n}\n\n/**\n* Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect. Sepcify a color as well.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `num_strips` - The numbder of strips\n* * `color` - Color of strips.\n* # Example\n*\n* ```no_run\n* // For example, to draw red vertical strips on a `PhotonImage`:\n* use photon_rs::effects::color_vertical_strips;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgb;\n*\n* let color = Rgb::new(255u8, 0u8, 0u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* color_vertical_strips(&mut img, 8u8, color);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} num_strips\n* @param {Rgb} color\n*/\nfunction color_vertical_strips(photon_image, num_strips, color) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(num_strips);\n    _assertClass(color, Rgb);\n    if (color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = color.__destroy_into_raw();\n    wasm.color_vertical_strips(photon_image.__wbg_ptr, num_strips, ptr0);\n}\n\n/**\n* Turn an image into an oil painting\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `radius` - Radius of each paint particle\n* * `intesnity` - How artsy an Image should be\n* # Example\n*\n* ```no_run\n* // For example, to oil an image of type `PhotonImage`:\n* use photon_rs::effects::oil;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* oil(&mut img, 4i32, 55.0);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} radius\n* @param {number} intensity\n*/\nfunction oil(photon_image, radius, intensity) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(radius);\n    wasm.oil(photon_image.__wbg_ptr, radius, intensity);\n}\n\n/**\n* Turn an image into an frosted glass see through\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to turn an image of type `PhotonImage` into frosted glass see through:\n* use photon_rs::effects::frosted_glass;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* frosted_glass(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction frosted_glass(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.frosted_glass(photon_image.__wbg_ptr);\n}\n\n/**\n* Pixelize an image.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage that contains a view into the image.\n* * `pixel_size` - Targeted pixel size of generated image.\n* # Example\n*\n* ```no_run\n* // For example, to turn an image of type `PhotonImage` into a pixelized image with 50 pixels blocks:\n* use photon_rs::effects::pixelize;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* pixelize(&mut img, 50);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} pixel_size\n*/\nfunction pixelize(photon_image, pixel_size) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(pixel_size);\n    wasm.pixelize(photon_image.__wbg_ptr, pixel_size);\n}\n\n/**\n* Normalizes an image by remapping its range of pixels values. Only RGB\n* channels are processed and each channel is stretched to \\[0, 255\\] range\n* independently. This process is also known as contrast stretching.\n* # Arguments\n* * `photon_image` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to turn an image of type `PhotonImage` into a normalized image:\n* use photon_rs::effects::normalize;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* normalize(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction normalize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.normalize(photon_image.__wbg_ptr);\n}\n\n/**\n* Applies Floyd-Steinberg dithering to an image.\n* Only RGB channels are processed, alpha remains unchanged.\n* # Arguments\n* * `photon_image` - A PhotonImage that contains a view into the image.\n* * `depth` - bits per channel. Clamped between 1 and 8.\n* # Example\n*\n* ```no_run\n* // For example, to turn an image of type `PhotonImage` into a dithered image:\n* use photon_rs::effects::dither;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let depth = 1;\n* dither(&mut img, depth);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} depth\n*/\nfunction dither(photon_image, depth) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(depth);\n    wasm.dither(photon_image.__wbg_ptr, depth);\n}\n\n/**\n* @param {PhotonImage} photon_image\n* @param {Rgb} color_a\n* @param {Rgb} color_b\n*/\nfunction duotone(photon_image, color_a, color_b) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(color_a, Rgb);\n    if (color_a.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = color_a.__destroy_into_raw();\n    _assertClass(color_b, Rgb);\n    if (color_b.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr1 = color_b.__destroy_into_raw();\n    wasm.duotone(photon_image.__wbg_ptr, ptr0, ptr1);\n}\n\n/**\n* Alter a select channel by incrementing or decrementing its value by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel` - The channel you wish to alter, it should be either 0, 1 or 2,\n* representing R, G, or B respectively. (O=Red, 1=Green, 2=Blue)\n* * `amount` - The amount to increment/decrement the channel's value by for that pixel.\n* A positive value will increment/decrement the channel's value, a negative value will decrement the channel's value.\n*\n* ## Example\n*\n* ```no_run\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon_rs::channels::alter_channel;\n* use photon_rs::native::{open_image};\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_channel(&mut img, 0_usize, 10_i16);\n* ```\n*\n* Adds a constant to a select R, G, or B channel's value.\n*\n* ### Decrease a channel's value\n* // For example, to decrease the Green channel for all pixels by 20:\n* ```no_run\n* use photon_rs::channels::alter_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_channel(&mut img, 1_usize, -20_i16);\n* ```\n* **Note**: Note the use of a minus symbol when decreasing the channel.\n* @param {PhotonImage} img\n* @param {number} channel\n* @param {number} amt\n*/\nfunction alter_channel(img, channel, amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(channel);\n    _assertNum(amt);\n    wasm.alter_channel(img.__wbg_ptr, channel, amt);\n}\n\n/**\n* Increment or decrement every pixel's Red channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `amt` - The amount to increment or decrement the channel's value by for that pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon_rs::channels::alter_red_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_red_channel(&mut img, 10_i16);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} amt\n*/\nfunction alter_red_channel(photon_image, amt) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(amt);\n    wasm.alter_red_channel(photon_image.__wbg_ptr, amt);\n}\n\n/**\n* Increment or decrement every pixel's Green channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `amt` - The amount to increment/decrement the channel's value by for that pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the Green channel for all pixels by 20:\n* use photon_rs::channels::alter_green_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_green_channel(&mut img, 20_i16);\n* ```\n* @param {PhotonImage} img\n* @param {number} amt\n*/\nfunction alter_green_channel(img, amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(amt);\n    wasm.alter_green_channel(img.__wbg_ptr, amt);\n}\n\n/**\n* Increment or decrement every pixel's Blue channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `amt` - The amount to increment or decrement the channel's value by for that pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the Blue channel for all pixels by 10:\n* use photon_rs::channels::alter_blue_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_blue_channel(&mut img, 10_i16);\n* ```\n* @param {PhotonImage} img\n* @param {number} amt\n*/\nfunction alter_blue_channel(img, amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(amt);\n    wasm.alter_blue_channel(img.__wbg_ptr, amt);\n}\n\n/**\n* Increment/decrement two channels' values simultaneously by adding an amt to each channel per pixel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel1` - A usize from 0 to 2 that represents either the R, G or B channels.\n* * `amt1` - The amount to increment/decrement the channel's value by for that pixel.\n* * `channel2` -A usize from 0 to 2 that represents either the R, G or B channels.\n* * `amt2` - The amount to increment/decrement the channel's value by for that pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the values of the Red and Blue channels per pixel:\n* use photon_rs::channels::alter_two_channels;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_two_channels(&mut img, 0_usize, 10_i16, 2_usize, 20_i16);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel1\n* @param {number} amt1\n* @param {number} channel2\n* @param {number} amt2\n*/\nfunction alter_two_channels(img, channel1, amt1, channel2, amt2) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(channel1);\n    _assertNum(amt1);\n    _assertNum(channel2);\n    _assertNum(amt2);\n    wasm.alter_two_channels(img.__wbg_ptr, channel1, amt1, channel2, amt2);\n}\n\n/**\n* Increment all 3 channels' values by adding an amt to each channel per pixel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `r_amt` - The amount to increment/decrement the Red channel by.\n* * `g_amt` - The amount to increment/decrement the Green channel by.\n* * `b_amt` - The amount to increment/decrement the Blue channel by.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the values of the Red channel by 10, the Green channel by 20,\n* // and the Blue channel by 50:\n* use photon_rs::channels::alter_channels;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_channels(&mut img, 10_i16, 20_i16, 50_i16);\n* ```\n* @param {PhotonImage} img\n* @param {number} r_amt\n* @param {number} g_amt\n* @param {number} b_amt\n*/\nfunction alter_channels(img, r_amt, g_amt, b_amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(r_amt);\n    _assertNum(g_amt);\n    _assertNum(b_amt);\n    wasm.alter_channels(img.__wbg_ptr, r_amt, g_amt, b_amt);\n}\n\n/**\n* Set a certain channel to zero, thus removing the channel's influence in the pixels' final rendered colour.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel` - The channel to be removed; must be a usize from 0 to 2, with 0 representing Red, 1 representing Green, and 2 representing Blue.\n* * `min_filter` - Minimum filter. Value between 0 and 255. Only remove the channel if the current pixel's channel value is less than this minimum filter. To completely\n* remove the channel, set this value to 255, to leave the channel as is, set to 0, and to set a channel to zero for a pixel whose red value is greater than 50,\n* then channel would be 0 and min_filter would be 50.\n*\n* # Example\n*\n* ```no_run\n* // For example, to remove the Red channel with a min_filter of 100:\n* use photon_rs::channels::remove_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* remove_channel(&mut img, 0_usize, 100_u8);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel\n* @param {number} min_filter\n*/\nfunction remove_channel(img, channel, min_filter) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(channel);\n    _assertNum(min_filter);\n    wasm.remove_channel(img.__wbg_ptr, channel, min_filter);\n}\n\n/**\n* Remove the Red channel's influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```no_run\n* // For example, to remove the red channel for red channel pixel values less than 50:\n* use photon_rs::channels::remove_red_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* remove_red_channel(&mut img, 50_u8);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n*/\nfunction remove_red_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(min_filter);\n    wasm.remove_red_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n* Remove the Green channel's influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```no_run\n* // For example, to remove the green channel for green channel pixel values less than 50:\n* use photon_rs::channels::remove_green_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* remove_green_channel(&mut img, 50_u8);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n*/\nfunction remove_green_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(min_filter);\n    wasm.remove_green_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n* Remove the Blue channel's influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```no_run\n* // For example, to remove the blue channel for blue channel pixel values less than 50:\n* use photon_rs::channels::remove_blue_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* remove_blue_channel(&mut img, 50_u8);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n*/\nfunction remove_blue_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(min_filter);\n    wasm.remove_blue_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n* Swap two channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel1` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Red would be represented by 0, Green by 1, and Blue by 2.\n* * `channel2` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Same as above.\n*\n* # Example\n*\n* ```no_run\n* // For example, to swap the values of the Red channel with the values of the Blue channel:\n* use photon_rs::channels::swap_channels;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* swap_channels(&mut img, 0_usize, 2_usize);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel1\n* @param {number} channel2\n*/\nfunction swap_channels(img, channel1, channel2) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(channel1);\n    _assertNum(channel2);\n    wasm.swap_channels(img.__wbg_ptr, channel1, channel2);\n}\n\n/**\n* Invert RGB value of an image.\n*\n* # Arguments\n* * `photon_image` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* use photon_rs::channels::invert;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* invert(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction invert(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.invert(photon_image.__wbg_ptr);\n}\n\n/**\n* Selective hue rotation.\n*\n* Only rotate the hue of a pixel if its RGB values are within a specified range.\n* This function only rotates a pixel's hue to another  if it is visually similar to the colour specified.\n* For example, if a user wishes all pixels that are blue to be changed to red, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `degrees` - The amount of degrees to hue rotate by.\n*\n* # Example\n*\n* ```no_run\n* // For example, to only rotate the pixels that are of RGB value RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_hue_rotate;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_hue_rotate(&mut img, ref_color, 180_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n* @param {number} degrees\n*/\nfunction selective_hue_rotate(photon_image, ref_color, degrees) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(ref_color, Rgb);\n    if (ref_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_hue_rotate(photon_image.__wbg_ptr, ptr0, degrees);\n}\n\n/**\n* Selectively change pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only changes the color of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, with this function, a user can change the color of all blue pixels by mixing them with red by 10%.\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `new_color` - The `RGB` value of the new color (to be mixed with the matched pixels)\n* * `fraction` - The amount of mixing the new colour with the matched pixels\n*\n* # Example\n*\n* ```no_run\n* // For example, to only change the color of pixels that are similar to the RGB value RGB{200, 120, 30} by mixing RGB{30, 120, 200} with 25%:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_color_convert;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(200, 120, 30);\n* let new_color = Rgb::new(30, 120, 200);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_color_convert(&mut img, ref_color, new_color, 0.25);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n* @param {Rgb} new_color\n* @param {number} fraction\n*/\nfunction selective_color_convert(photon_image, ref_color, new_color, fraction) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(ref_color, Rgb);\n    if (ref_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = ref_color.__destroy_into_raw();\n    _assertClass(new_color, Rgb);\n    if (new_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr1 = new_color.__destroy_into_raw();\n    wasm.selective_color_convert(photon_image.__wbg_ptr, ptr0, ptr1, fraction);\n}\n\n/**\n* Selectively lighten an image.\n*\n* Only lighten the hue of a pixel if its colour matches or is similar to the RGB colour specified.\n* For example, if a user wishes all pixels that are blue to be lightened, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The level from 0 to 1 to lighten the hue by. Increasing by 10% would have an `amt` of 0.1\n*\n* # Example\n*\n* ```no_run\n* // For example, to only lighten the pixels that are of or similar to RGB value RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_lighten;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_lighten(&mut img, ref_color, 0.2_f32);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n*/\nfunction selective_lighten(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(ref_color, Rgb);\n    if (ref_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_lighten(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n* Selectively desaturate pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only desaturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, if a user wishes all pixels that are blue to be desaturated by 0.1, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The amount of desaturate the colour by.\n*\n* # Example\n*\n* ```no_run\n* // For example, to only desaturate the pixels that are similar to the RGB value RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_desaturate;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_desaturate(&mut img, ref_color, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n*/\nfunction selective_desaturate(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(ref_color, Rgb);\n    if (ref_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_desaturate(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n* Selectively saturate pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only saturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, if a user wishes all pixels that are blue to have an increase in saturation by 10%, they can selectively specify only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The amount of saturate the colour by.\n*\n* # Example\n*\n* ```no_run\n* // For example, to only increase the saturation of pixels that are similar to the RGB value RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_saturate;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_saturate(&mut img, ref_color, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n*/\nfunction selective_saturate(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(ref_color, Rgb);\n    if (ref_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_saturate(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n* Selectively changes a pixel to greyscale if it is *not* visually similar or close to the colour specified.\n* Only changes the colour of a pixel if its RGB values are within a specified range.\n*\n* (Similarity between two colours is calculated via the CIE76 formula.)\n* For example, if a user wishes all pixels that are *NOT* blue to be displayed in greyscale, they can selectively specify only the blue pixels to be\n* kept in the photo.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n*\n* # Example\n*\n* ```no_run\n* // For example, to greyscale all pixels that are *not* visually similar to the RGB colour RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_greyscale;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_greyscale(img, ref_color);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n*/\nfunction selective_greyscale(photon_image, ref_color) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = photon_image.__destroy_into_raw();\n    _assertClass(ref_color, Rgb);\n    if (ref_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr1 = ref_color.__destroy_into_raw();\n    wasm.selective_greyscale(ptr0, ptr1);\n}\n\n/**\n* Add bordered-text to an image.\n* The only font available as of now is Roboto.\n* Note: A graphic design/text-drawing library is currently being developed, so stay tuned.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `text` - Text string to be drawn to the image.\n* * `x` - x-coordinate of where first letter's 1st pixel should be drawn.\n* * `y` - y-coordinate of where first letter's 1st pixel should be drawn.\n*\n* # Example\n*\n* ```no_run\n* // For example to draw the string \"Welcome to Photon!\" at 10, 10:\n* use photon_rs::native::open_image;\n* use photon_rs::text::draw_text_with_border;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* draw_text_with_border(&mut img, \"Welcome to Photon!\", 10_i32, 10_i32);\n* ```\n* @param {PhotonImage} photon_img\n* @param {string} text\n* @param {number} x\n* @param {number} y\n*/\nfunction draw_text_with_border(photon_img, text, x, y) {\n    _assertClass(photon_img, PhotonImage);\n    if (photon_img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    _assertNum(x);\n    _assertNum(y);\n    wasm.draw_text_with_border(photon_img.__wbg_ptr, ptr0, len0, x, y);\n}\n\n/**\n* Add text to an image.\n* The only font available as of now is Roboto.\n* Note: A graphic design/text-drawing library is currently being developed, so stay tuned.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `text` - Text string to be drawn to the image.\n* * `x` - x-coordinate of where first letter's 1st pixel should be drawn.\n* * `y` - y-coordinate of where first letter's 1st pixel should be drawn.\n*\n* # Example\n*\n* ```no_run\n* // For example to draw the string \"Welcome to Photon!\" at 10, 10:\n* use photon_rs::native::open_image;\n* use photon_rs::text::draw_text;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* draw_text(&mut img, \"Welcome to Photon!\", 10_i32, 10_i32);\n* ```\n* @param {PhotonImage} photon_img\n* @param {string} text\n* @param {number} x\n* @param {number} y\n*/\nfunction draw_text(photon_img, text, x, y) {\n    _assertClass(photon_img, PhotonImage);\n    if (photon_img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    _assertNum(x);\n    _assertNum(y);\n    wasm.draw_text(photon_img.__wbg_ptr, ptr0, len0, x, y);\n}\n\n/**\n* Apply a monochrome effect of a certain colour.\n*\n* It does so by averaging the R, G, and B values of a pixel, and then adding a\n* separate value to that averaged value for each channel to produce a tint.\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `r_offset` - The value to add to the Red channel per pixel.\n* * `g_offset` - The value to add to the Green channel per pixel.\n* * `b_offset` - The value to add to the Blue channel per pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a monochrome effect to an image:\n* use photon_rs::monochrome::monochrome;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* monochrome(&mut img, 40_u32, 50_u32, 100_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n*/\nfunction monochrome(img, r_offset, g_offset, b_offset) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(r_offset);\n    _assertNum(g_offset);\n    _assertNum(b_offset);\n    wasm.monochrome(img.__wbg_ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n* Convert an image to sepia.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to sepia an image of type `PhotonImage`:\n* use photon_rs::monochrome::sepia;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* sepia(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction sepia(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.sepia(img.__wbg_ptr);\n}\n\n/**\n* Convert an image to grayscale using the conventional averaging algorithm.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to convert an image of type `PhotonImage` to grayscale:\n* use photon_rs::monochrome::grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* grayscale(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction grayscale(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.grayscale(img.__wbg_ptr);\n}\n\n/**\n* Convert an image to grayscale with a human corrected factor, to account for human vision.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to convert an image of type `PhotonImage` to grayscale with a human corrected factor:\n* use photon_rs::monochrome::grayscale_human_corrected;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* grayscale_human_corrected(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction grayscale_human_corrected(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.grayscale_human_corrected(img.__wbg_ptr);\n}\n\n/**\n* Desaturate an image by getting the min/max of each pixel's RGB values.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to desaturate an image:\n* use photon_rs::monochrome::desaturate;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction desaturate(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.desaturate(img.__wbg_ptr);\n}\n\n/**\n* Uses a min. decomposition algorithm to convert an image to greyscale.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to decompose an image with min decomposition:\n* use photon_rs::monochrome::decompose_min;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* decompose_min(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction decompose_min(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.decompose_min(img.__wbg_ptr);\n}\n\n/**\n* Uses a max. decomposition algorithm to convert an image to greyscale.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to decompose an image with max decomposition:\n* use photon_rs::monochrome::decompose_max;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* decompose_max(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction decompose_max(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.decompose_max(img.__wbg_ptr);\n}\n\n/**\n* Employ only a limited number of gray shades in an image.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `num_shades` - The number of grayscale shades to be displayed in the image.\n* # Example\n*\n* ```no_run\n* // For example, to limit an image to four shades of gray only:\n* use photon_rs::monochrome::grayscale_shades;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* grayscale_shades(&mut img, 4_u8);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} num_shades\n*/\nfunction grayscale_shades(photon_image, num_shades) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(num_shades);\n    wasm.grayscale_shades(photon_image.__wbg_ptr, num_shades);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel's 3 RGB values to the Red channel's value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::monochrome::r_grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* r_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction r_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.r_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel's 3 RGB values to the Green channel's value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::monochrome::g_grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* g_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction g_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.g_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel's 3 RGB values to the Blue channel's value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::monochrome::b_grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* b_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction b_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.b_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel's 3 RGB values to a chosen channel's value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `channel` - A usize representing the channel from 0 to 2. O represents the Red channel, 1 the Green channel, and 2 the Blue channel.\n* # Example\n* To grayscale using only values from the Red channel:\n* ```no_run\n* use photon_rs::monochrome::single_channel_grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* single_channel_grayscale(&mut img, 0_usize);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel\n*/\nfunction single_channel_grayscale(photon_image, channel) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(channel);\n    wasm.single_channel_grayscale(photon_image.__wbg_ptr, channel);\n}\n\n/**\n* Threshold an image using a standard thresholding algorithm.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `threshold` - The amount the image should be thresholded by from 0 to 255.\n* # Example\n*\n* ```no_run\n* // For example, to threshold an image of type `PhotonImage`:\n* use photon_rs::monochrome::threshold;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* threshold(&mut img, 30_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} threshold\n*/\nfunction threshold(img, threshold) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(threshold);\n    wasm.threshold(img.__wbg_ptr, threshold);\n}\n\n/**\n* Add randomized noise to an image.\n* This function adds a Gaussian Noise Sample to each pixel through incrementing each channel by a randomized offset.\n* This randomized offset is generated by creating a randomized thread pool.\n* **[WASM SUPPORT IS AVAILABLE]**: Randomized thread pools cannot be created with WASM, but\n* a workaround using js_sys::Math::random works now.\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example:\n* use photon_rs::native::open_image;\n* use photon_rs::noise::add_noise_rand;\n* use photon_rs::PhotonImage;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* add_noise_rand(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction add_noise_rand(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.add_noise_rand(photon_image.__wbg_ptr);\n}\n\n/**\n* Add pink-tinted noise to an image.\n*\n* **[WASM SUPPORT IS AVAILABLE]**: Randomized thread pools cannot be created with WASM, but\n* a workaround using js_sys::Math::random works now.\n* # Arguments\n* * `name` - A PhotonImage that contains a view into the image.\n*\n* # Example\n*\n* ```no_run\n* // For example, to add pink-tinted noise to an image:\n* use photon_rs::native::open_image;\n* use photon_rs::noise::pink_noise;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* pink_noise(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction pink_noise(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.pink_noise(photon_image.__wbg_ptr);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n*! [temp] Check if WASM is supported.\n*/\nfunction run() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.run(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n* Get the ImageData from a 2D canvas context\n* @param {HTMLCanvasElement} canvas\n* @param {CanvasRenderingContext2D} ctx\n* @returns {ImageData}\n*/\nfunction get_image_data(canvas, ctx) {\n    try {\n        const ret = wasm.get_image_data(addBorrowedObject(canvas), addBorrowedObject(ctx));\n        return takeObject(ret);\n    } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n    }\n}\n\n/**\n* Place a PhotonImage onto a 2D canvas.\n* @param {HTMLCanvasElement} canvas\n* @param {CanvasRenderingContext2D} ctx\n* @param {PhotonImage} new_image\n*/\nfunction putImageData(canvas, ctx, new_image) {\n    _assertClass(new_image, PhotonImage);\n    if (new_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = new_image.__destroy_into_raw();\n    wasm.putImageData(addHeapObject(canvas), addHeapObject(ctx), ptr0);\n}\n\n/**\n* Convert a HTML5 Canvas Element to a PhotonImage.\n*\n* This converts the ImageData found in the canvas context to a PhotonImage,\n* which can then have effects or filters applied to it.\n* @param {HTMLCanvasElement} canvas\n* @param {CanvasRenderingContext2D} ctx\n* @returns {PhotonImage}\n*/\nfunction open_image(canvas, ctx) {\n    const ret = wasm.open_image(addHeapObject(canvas), addHeapObject(ctx));\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Convert ImageData to a raw pixel vec of u8s.\n* @param {ImageData} imgdata\n* @returns {Uint8Array}\n*/\nfunction to_raw_pixels(imgdata) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.to_raw_pixels(retptr, addHeapObject(imgdata));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Convert a base64 string to a PhotonImage.\n* @param {string} base64\n* @returns {PhotonImage}\n*/\nfunction base64_to_image(base64) {\n    const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.base64_to_image(ptr0, len0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Convert a base64 string to a Vec of u8s.\n* @param {string} base64\n* @returns {Uint8Array}\n*/\nfunction base64_to_vec(base64) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.base64_to_vec(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Convert a PhotonImage to JS-compatible ImageData.\n* @param {PhotonImage} photon_image\n* @returns {ImageData}\n*/\nfunction to_image_data(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = photon_image.__destroy_into_raw();\n    const ret = wasm.to_image_data(ptr0);\n    return takeObject(ret);\n}\n\n/**\n* Crop an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to crop an image at (0, 0) to (500, 800)\n* use photon_rs::native::{open_image};\n* use photon_rs::transform::crop;\n* use photon_rs::PhotonImage;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let cropped_img: PhotonImage = crop(&mut img, 0_u32, 0_u32, 500_u32, 800_u32);\n* // Write the contents of this image in JPG format.\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} x1\n* @param {number} y1\n* @param {number} x2\n* @param {number} y2\n* @returns {PhotonImage}\n*/\nfunction crop(photon_image, x1, y1, x2, y2) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(x1);\n    _assertNum(y1);\n    _assertNum(x2);\n    _assertNum(y2);\n    const ret = wasm.crop(photon_image.__wbg_ptr, x1, y1, x2, y2);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* @param {HTMLCanvasElement} source_canvas\n* @param {number} width\n* @param {number} height\n* @param {number} left\n* @param {number} top\n* @returns {HTMLCanvasElement}\n*/\nfunction crop_img_browser(source_canvas, width, height, left, top) {\n    const ret = wasm.crop_img_browser(addHeapObject(source_canvas), width, height, left, top);\n    return takeObject(ret);\n}\n\n/**\n* Flip an image horizontally.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to flip an image horizontally:\n* use photon_rs::native::open_image;\n* use photon_rs::transform::fliph;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* fliph(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction fliph(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.fliph(photon_image.__wbg_ptr);\n}\n\n/**\n* Flip an image vertically.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to flip an image vertically:\n* use photon_rs::native::open_image;\n* use photon_rs::transform::flipv;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* flipv(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction flipv(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.flipv(photon_image.__wbg_ptr);\n}\n\n/**\n* Resize an image on the web.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `width` - New width.\n* * `height` - New height.\n* * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5\n* @param {PhotonImage} photon_img\n* @param {number} width\n* @param {number} height\n* @param {number} sampling_filter\n* @returns {HTMLCanvasElement}\n*/\nfunction resize_img_browser(photon_img, width, height, sampling_filter) {\n    _assertClass(photon_img, PhotonImage);\n    if (photon_img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(width);\n    _assertNum(height);\n    _assertNum(sampling_filter);\n    const ret = wasm.resize_img_browser(photon_img.__wbg_ptr, width, height, sampling_filter);\n    return takeObject(ret);\n}\n\n/**\n* Resize an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `width` - New width.\n* * `height` - New height.\n* * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5\n* @param {PhotonImage} photon_img\n* @param {number} width\n* @param {number} height\n* @param {number} sampling_filter\n* @returns {PhotonImage}\n*/\nfunction resize(photon_img, width, height, sampling_filter) {\n    _assertClass(photon_img, PhotonImage);\n    if (photon_img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(width);\n    _assertNum(height);\n    _assertNum(sampling_filter);\n    const ret = wasm.resize(photon_img.__wbg_ptr, width, height, sampling_filter);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Resize image using seam carver.\n* Resize only if new dimensions are smaller, than original image.\n* # NOTE: This is still experimental feature, and pretty slow.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `width` - New width.\n* * `height` - New height.\n*\n* # Example\n*\n* ```no_run\n* // For example, resize image using seam carver:\n* use photon_rs::native::open_image;\n* use photon_rs::transform::seam_carve;\n* use photon_rs::PhotonImage;\n*\n* let img = open_image(\"img.jpg\").expect(\"File should open\");\n* let result: PhotonImage = seam_carve(&img, 100_u32, 100_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} width\n* @param {number} height\n* @returns {PhotonImage}\n*/\nfunction seam_carve(img, width, height) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(width);\n    _assertNum(height);\n    const ret = wasm.seam_carve(img.__wbg_ptr, width, height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Apply uniform padding around the PhotonImage\n* A padded PhotonImage is returned.\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `padding` - The amount of padding to be applied to the PhotonImage.\n* * `padding_rgba` - Tuple containing the RGBA code for padding color.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a padding of 10 pixels around a PhotonImage:\n* use photon_rs::transform::padding_uniform;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgba;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n* padding_uniform(&img, 10_u32, rgba);\n* ```\n* @param {PhotonImage} img\n* @param {number} padding\n* @param {Rgba} padding_rgba\n* @returns {PhotonImage}\n*/\nfunction padding_uniform(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(padding);\n    _assertClass(padding_rgba, Rgba);\n    if (padding_rgba.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_uniform(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Apply padding on the left side of the PhotonImage\n* A padded PhotonImage is returned.\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `padding` - The amount of padding to be applied to the PhotonImage.\n* * `padding_rgba` - Tuple containing the RGBA code for padding color.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a padding of 10 pixels on the left side of a PhotonImage:\n* use photon_rs::transform::padding_left;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgba;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n* padding_left(&img, 10_u32, rgba);\n* ```\n* @param {PhotonImage} img\n* @param {number} padding\n* @param {Rgba} padding_rgba\n* @returns {PhotonImage}\n*/\nfunction padding_left(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(padding);\n    _assertClass(padding_rgba, Rgba);\n    if (padding_rgba.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_left(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Apply padding on the left side of the PhotonImage\n* A padded PhotonImage is returned.\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `padding` - The amount of padding to be applied to the PhotonImage.\n* * `padding_rgba` - Tuple containing the RGBA code for padding color.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a padding of 10 pixels on the right side of a PhotonImage:\n* use photon_rs::transform::padding_right;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgba;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n* padding_right(&img, 10_u32, rgba);\n* ```\n* @param {PhotonImage} img\n* @param {number} padding\n* @param {Rgba} padding_rgba\n* @returns {PhotonImage}\n*/\nfunction padding_right(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(padding);\n    _assertClass(padding_rgba, Rgba);\n    if (padding_rgba.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_right(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Apply padding on the left side of the PhotonImage\n* A padded PhotonImage is returned.\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `padding` - The amount of padding to be applied to the PhotonImage.\n* * `padding_rgba` - Tuple containing the RGBA code for padding color.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a padding of 10 pixels on the top of a PhotonImage:\n* use photon_rs::transform::padding_top;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgba;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n* padding_top(&img, 10_u32, rgba);\n* ```\n* @param {PhotonImage} img\n* @param {number} padding\n* @param {Rgba} padding_rgba\n* @returns {PhotonImage}\n*/\nfunction padding_top(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(padding);\n    _assertClass(padding_rgba, Rgba);\n    if (padding_rgba.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_top(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Apply padding on the left side of the PhotonImage\n* A padded PhotonImage is returned.\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `padding` - The amount of padding to be applied to the PhotonImage.\n* * `padding_rgba` - Tuple containing the RGBA code for padding color.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a padding of 10 pixels on the bottom of a PhotonImage:\n* use photon_rs::transform::padding_bottom;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgba;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n* padding_bottom(&img, 10_u32, rgba);\n* ```\n* @param {PhotonImage} img\n* @param {number} padding\n* @param {Rgba} padding_rgba\n* @returns {PhotonImage}\n*/\nfunction padding_bottom(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(padding);\n    _assertClass(padding_rgba, Rgba);\n    if (padding_rgba.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_bottom(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Rotate the PhotonImage on an arbitrary angle\n* A rotated PhotonImage is returned.\n* # NOTE: This is a naive implementation. Paeth rotation should be faster.\n*\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `angle` - Rotation angle in degrees.\n*\n* # Example\n*\n* ```no_run\n* // For example, to rotate a PhotonImage by 30 degrees:\n* use photon_rs::native::open_image;\n* use photon_rs::transform::rotate;\n*\n* let img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rotated_img = rotate(&img, 30);\n* ```\n* @param {PhotonImage} img\n* @param {number} angle\n* @returns {PhotonImage}\n*/\nfunction rotate(img, angle) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(angle);\n    const ret = wasm.rotate(img.__wbg_ptr, angle);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Resample the PhotonImage.\n*\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `dst_width` - Target width.\n* * `dst_height` - Target height.\n*\n* # Example\n*\n* ```no_run\n* // For example, to resample a PhotonImage to 1920x1080 size:\n* use photon_rs::native::open_image;\n* use photon_rs::transform::resample;\n*\n* let img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rotated_img = resample(&img, 1920, 1080);\n* ```\n* @param {PhotonImage} img\n* @param {number} dst_width\n* @param {number} dst_height\n* @returns {PhotonImage}\n*/\nfunction resample(img, dst_width, dst_height) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(dst_width);\n    _assertNum(dst_height);\n    const ret = wasm.resample(img.__wbg_ptr, dst_width, dst_height);\n    return PhotonImage.__wrap(ret);\n}\n\nfunction _assertBigInt(n) {\n    if (typeof(n) !== 'bigint') throw new Error('expected a bigint argument');\n}\n/**\n* Add a watermark to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `watermark` - The watermark to be placed onto the `img` image.\n* * `x` - The x coordinate where the watermark's top corner should be positioned.\n* * `y` - The y coordinate where the watermark's top corner should be positioned.\n* # Example\n*\n* ```no_run\n* // For example, to add a watermark to an image at x: 30, y: 40:\n* use photon_rs::multiple::watermark;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let water_mark = open_image(\"watermark.jpg\").expect(\"File should open\");\n* watermark(&mut img, &water_mark, 30_i64, 40_i64);\n* ```\n* @param {PhotonImage} img\n* @param {PhotonImage} watermark\n* @param {bigint} x\n* @param {bigint} y\n*/\nfunction watermark(img, watermark, x, y) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(watermark, PhotonImage);\n    if (watermark.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertBigInt(x);\n    _assertBigInt(y);\n    wasm.watermark(img.__wbg_ptr, watermark.__wbg_ptr, x, y);\n}\n\n/**\n* Blend two images together.\n*\n* The `blend_mode` (3rd param) determines which blending mode to use; change this for varying effects.\n* The blend modes available include: `overlay`, `over`, `atop`, `xor`, `multiply`, `burn`, `soft_light`, `hard_light`,\n* `difference`, `lighten`, `darken`, `dodge`, `plus`, `exclusion` (more to come)\n* NOTE: The first image must be smaller than the second image passed as params.\n* If the first image were larger than the second, then there would be overflowing pixels which would have no corresponding pixels\n* in the second image.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `img2` - The 2nd DynamicImage to be blended with the first.\n* * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.\n* # Example\n*\n* ```no_run\n* // For example, to blend two images with the `multiply` blend mode:\n* use photon_rs::multiple::blend;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let img2 = open_image(\"img2.jpg\").expect(\"File should open\");\n* blend(&mut img, &img2, \"multiply\");\n* ```\n* @param {PhotonImage} photon_image\n* @param {PhotonImage} photon_image2\n* @param {string} blend_mode\n*/\nfunction blend(photon_image, photon_image2, blend_mode) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(photon_image2, PhotonImage);\n    if (photon_image2.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ptr0 = passStringToWasm0(blend_mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.blend(photon_image.__wbg_ptr, photon_image2.__wbg_ptr, ptr0, len0);\n}\n\n/**\n* @param {number} width\n* @param {number} height\n* @returns {PhotonImage}\n*/\nfunction create_gradient(width, height) {\n    _assertNum(width);\n    _assertNum(height);\n    const ret = wasm.create_gradient(width, height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Apply a gradient to an image.\n* @param {PhotonImage} image\n*/\nfunction apply_gradient(image) {\n    _assertClass(image, PhotonImage);\n    if (image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.apply_gradient(image.__wbg_ptr);\n}\n\n/**\n* Applies gamma correction to an image.\n* # Arguments\n* * `photon_image` - A PhotonImage that contains a view into the image.\n* * `red` - Gamma value for red channel.\n* * `green` - Gamma value for green channel.\n* * `blue` - Gamma value for blue channel.\n* # Example\n*\n* ```no_run\n* // For example, to turn an image of type `PhotonImage` into a gamma corrected image:\n* use photon_rs::colour_spaces::gamma_correction;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* gamma_correction(&mut img, 2.2, 2.2, 2.2);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} red\n* @param {number} green\n* @param {number} blue\n*/\nfunction gamma_correction(photon_image, red, green, blue) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.gamma_correction(photon_image.__wbg_ptr, red, green, blue);\n}\n\n/**\n* Image manipulation effects in the HSLuv colour space\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n* # Example\n* ```no_run\n* // For example to increase the saturation by 10%:\n* use photon_rs::colour_spaces::hsluv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hsluv(&mut img, \"saturate\", 0.1_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n*/\nfunction hsluv(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsluv(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n* Image manipulation effects in the LCh colour space\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n* # Example\n* ```no_run\n* // For example to increase the saturation by 10%:\n* use photon_rs::colour_spaces::lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lch(&mut img, \"saturate\", 0.1_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n*/\nfunction lch(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.lch(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n* Image manipulation effects in the HSL colour space.\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n* # Example\n* ```no_run\n* // For example to increase the saturation by 10%:\n* use photon_rs::colour_spaces::hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hsl(&mut img, \"saturate\", 0.1_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n*/\nfunction hsl(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsl(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n* Image manipulation in the HSV colour space.\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n*\n* # Example\n* ```no_run\n* // For example to increase the saturation by 10%:\n* use photon_rs::colour_spaces::hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hsv(&mut img, \"saturate\", 0.1_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n*/\nfunction hsv(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsv(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSL colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```no_run\n* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n* use photon_rs::colour_spaces::hue_rotate_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hue_rotate_hsl(&mut img, 120_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n*/\nfunction hue_rotate_hsl(img, degrees) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.hue_rotate_hsl(img.__wbg_ptr, degrees);\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSV colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```no_run\n* // For example to hue rotate/shift the hue by 120 degrees in the HSV colour space:\n* use photon_rs::colour_spaces::hue_rotate_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hue_rotate_hsv(&mut img, 120_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n*/\nfunction hue_rotate_hsv(img, degrees) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.hue_rotate_hsv(img.__wbg_ptr, degrees);\n}\n\n/**\n* Shift hue by a specified number of degrees in the LCh colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```no_run\n* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n* use photon_rs::colour_spaces::hue_rotate_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hue_rotate_lch(&mut img, 120_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n*/\nfunction hue_rotate_lch(img, degrees) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.hue_rotate_lch(img.__wbg_ptr, degrees);\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSLuv colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```no_run\n* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n* use photon_rs::colour_spaces::hue_rotate_hsluv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hue_rotate_hsluv(&mut img, 120_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n*/\nfunction hue_rotate_hsluv(img, degrees) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.hue_rotate_hsluv(img.__wbg_ptr, degrees);\n}\n\n/**\n* Increase the image's saturation by converting each pixel's colour to the HSL colour space\n* and increasing the colour's saturation.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to increase saturation by 10% in the HSL colour space:\n* use photon_rs::colour_spaces::saturate_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* saturate_hsl(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction saturate_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.saturate_hsl(img.__wbg_ptr, level);\n}\n\n/**\n* Increase the image's saturation in the LCh colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to increase saturation by 40% in the Lch colour space:\n* use photon_rs::colour_spaces::saturate_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* saturate_lch(&mut img, 0.4_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction saturate_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.saturate_lch(img.__wbg_ptr, level);\n}\n\n/**\n* Increase the image's saturation in the HSLuv colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to increase saturation by 40% in the HSLuv colour space:\n* use photon_rs::colour_spaces::saturate_hsluv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* saturate_hsluv(&mut img, 0.4_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction saturate_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.saturate_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n* Increase the image's saturation in the HSV colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level by which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to increase saturation by 30% in the HSV colour space:\n* use photon_rs::colour_spaces::saturate_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* saturate_hsv(&mut img, 0.3_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction saturate_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.saturate_hsv(img.__wbg_ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to lighten an image by 10% in the LCh colour space:\n* use photon_rs::colour_spaces::lighten_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lighten_lch(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction lighten_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.lighten_lch(img.__wbg_ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the HSLuv colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to lighten an image by 10% in the HSLuv colour space:\n* use photon_rs::colour_spaces::lighten_hsluv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lighten_hsluv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction lighten_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.lighten_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the HSL colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to lighten an image by 10% in the HSL colour space:\n* use photon_rs::colour_spaces::lighten_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lighten_hsl(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction lighten_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.lighten_hsl(img.__wbg_ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to lighten an image by 10% in the HSV colour space:\n* use photon_rs::colour_spaces::lighten_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lighten_hsv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction lighten_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.lighten_hsv(img.__wbg_ptr, level);\n}\n\n/**\n* Darken the image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to darken an image by 10% in the LCh colour space:\n* use photon_rs::colour_spaces::darken_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* darken_lch(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction darken_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.darken_lch(img.__wbg_ptr, level);\n}\n\n/**\n* Darken the image by a specified amount in the HSLuv colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to darken an image by 10% in the HSLuv colour space:\n* use photon_rs::colour_spaces::darken_hsluv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* darken_hsluv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction darken_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.darken_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n* Darken the image by a specified amount in the HSL colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to darken an image by 10% in the HSL colour space:\n* use photon_rs::colour_spaces::darken_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* darken_hsl(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction darken_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.darken_hsl(img.__wbg_ptr, level);\n}\n\n/**\n* Darken the image's colours by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to darken an image by 10% in the HSV colour space:\n* use photon_rs::colour_spaces::darken_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* darken_hsv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction darken_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.darken_hsv(img.__wbg_ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to desaturate an image by 10% in the HSV colour space:\n* use photon_rs::colour_spaces::desaturate_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate_hsv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction desaturate_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.desaturate_hsv(img.__wbg_ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the HSL colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to desaturate an image by 10% in the LCh colour space:\n* use photon_rs::colour_spaces::desaturate_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate_hsl(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction desaturate_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.desaturate_hsl(img.__wbg_ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to desaturate an image by 10% in the LCh colour space:\n* use photon_rs::colour_spaces::desaturate_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate_lch(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction desaturate_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.desaturate_lch(img.__wbg_ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the HSLuv colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to desaturate an image by 10% in the HSLuv colour space:\n* use photon_rs::colour_spaces::desaturate_hsluv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate_hsluv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nfunction desaturate_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.desaturate_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n* Mix image with a single color, supporting passing `opacity`.\n* The algorithm comes from Jimp. See `function mix` and `function colorFn` at following link:\n* https://github.com/oliver-moran/jimp/blob/29679faa597228ff2f20d34c5758e4d2257065a3/packages/plugin-color/src/index.js\n* Specifically, result_value = (mix_color_value - origin_value) * opacity + origin_value =\n* mix_color_value * opacity + (1 - opacity) * origin_value for each\n* of RGB channel.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage that contains a view into the image.\n* * `mix_color` - the color to be mixed in, as an RGB value.\n* * `opacity` - the opacity of color when mixed to image. Float value from 0 to 1.\n* # Example\n*\n* ```no_run\n* // For example, to mix an image with rgb (50, 255, 254) and opacity 0.4:\n* use photon_rs::Rgb;\n* use photon_rs::colour_spaces::mix_with_colour;\n* use photon_rs::native::open_image;\n*\n* let mix_colour = Rgb::new(50_u8, 255_u8, 254_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* mix_with_colour(&mut img, mix_colour, 0.4_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} mix_colour\n* @param {number} opacity\n*/\nfunction mix_with_colour(photon_image, mix_colour, opacity) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(mix_colour, Rgb);\n    if (mix_colour.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = mix_colour.__destroy_into_raw();\n    wasm.mix_with_colour(photon_image.__wbg_ptr, ptr0, opacity);\n}\n\n/**\n* Solarization on the Blue channel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::neue;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* neue(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction neue(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.neue(photon_image.__wbg_ptr);\n}\n\n/**\n* Solarization on the Red and Green channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::lix;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lix(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction lix(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.lix(photon_image.__wbg_ptr);\n}\n\n/**\n* Solarization on the Red and Blue channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::ryo;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* ryo(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction ryo(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.ryo(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply a filter to an image. Over 20 filters are available.\n* The filters are as follows:\n* * **oceanic**: Add an aquamarine-tinted hue to an image.\n* * **islands**: Aquamarine tint.\n* * **marine**: Add a green/blue mixed hue to an image.\n* * **seagreen**: Dark green hue, with tones of blue.\n* * **flagblue**: Royal blue tint\n* * **liquid**: Blue-inspired tint.\n* * **diamante**: Custom filter with a blue/turquoise tint.\n* * **radio**: Fallout-style radio effect.\n* * **twenties**: Slight-blue tinted historical effect.\n* * **rosetint**: Rose-tinted filter.\n* * **mauve**: Purple-infused filter.\n* * **bluechrome**: Blue monochrome effect.\n* * **vintage**: Vintage filter with a red tint.\n* * **perfume**: Increase the blue channel, with moderate increases in the Red and Green channels.\n* * **serenity**: Custom filter with an increase in the Blue channel's values.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `filter_name` - The filter's name. Choose from the selection above, eg: \"oceanic\"\n* # Example\n*\n* ```no_run\n* // For example, to add a filter called \"vintage\" to an image:\n* use photon_rs::filters::filter;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* filter(&mut img, \"vintage\");\n* ```\n* @param {PhotonImage} img\n* @param {string} filter_name\n*/\nfunction filter(img, filter_name) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    const ptr0 = passStringToWasm0(filter_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.filter(img.__wbg_ptr, ptr0, len0);\n}\n\n/**\n* Apply a lofi effect to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::lofi;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lofi(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction lofi(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.lofi(img.__wbg_ptr);\n}\n\n/**\n* Apply a rose tint to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::pastel_pink;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* pastel_pink(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction pastel_pink(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.pastel_pink(img.__wbg_ptr);\n}\n\n/**\n* Apply a vintage, golden hue to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::golden;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* golden(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction golden(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.golden(img.__wbg_ptr);\n}\n\n/**\n* Increased contrast filter effect.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::cali;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* cali(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction cali(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.cali(img.__wbg_ptr);\n}\n\n/**\n* Greyscale effect with increased contrast.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::dramatic;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* dramatic(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction dramatic(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.dramatic(img.__wbg_ptr);\n}\n\n/**\n* Monochrome tint effect with increased contrast\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `rgb_color` - RGB color\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::monochrome_tint;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgb;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rgb_color = Rgb::new(12, 12, 10);\n* monochrome_tint(&mut img, rgb_color);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} rgb_color\n*/\nfunction monochrome_tint(img, rgb_color) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(rgb_color, Rgb);\n    if (rgb_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = rgb_color.__destroy_into_raw();\n    wasm.monochrome_tint(img.__wbg_ptr, ptr0);\n}\n\n/**\n* Duotone effect with blue and purple tones.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::duotone_violette;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* duotone_violette(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction duotone_violette(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.duotone_violette(img.__wbg_ptr);\n}\n\n/**\n* Duotone effect with purple tones.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::duotone_horizon;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* duotone_horizon(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction duotone_horizon(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.duotone_horizon(img.__wbg_ptr);\n}\n\n/**\n* A duotone filter with a user-specified color and a gray color\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `rgb_color` - RGB color\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::duotone_tint;\n* use photon_rs::native::open_image;\n* use photon_rs::Rgb;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let rgb_color = Rgb::new(12, 12, 10);\n* duotone_tint(&mut img, rgb_color);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} rgb_color\n*/\nfunction duotone_tint(img, rgb_color) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertClass(rgb_color, Rgb);\n    if (rgb_color.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    var ptr0 = rgb_color.__destroy_into_raw();\n    wasm.duotone_tint(img.__wbg_ptr, ptr0);\n}\n\n/**\n* Duotone effect with a lilac hue\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::duotone_lilac;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* duotone_lilac(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction duotone_lilac(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.duotone_lilac(img.__wbg_ptr);\n}\n\n/**\n* A duotone ochre tint effect\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::duotone_ochre;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* duotone_ochre(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction duotone_ochre(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.duotone_ochre(img.__wbg_ptr);\n}\n\n/**\n* Apply a red hue, with increased contrast and brightness.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::firenze;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* firenze(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction firenze(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.firenze(img.__wbg_ptr);\n}\n\n/**\n* Apply a greyscale effect with increased contrast.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::obsidian;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* obsidian(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nfunction obsidian(img) {\n    _assertClass(img, PhotonImage);\n    if (img.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.obsidian(img.__wbg_ptr);\n}\n\n/**\n* sander says: The median was the message\n* @param {PhotonImage} image\n* @param {number} x_radius\n* @param {number} y_radius\n*/\nfunction median(image, x_radius, y_radius) {\n    _assertClass(image, PhotonImage);\n    if (image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(x_radius);\n    _assertNum(y_radius);\n    wasm.median(image.__wbg_ptr, x_radius, y_radius);\n}\n\n/**\n* Noise reduction.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to noise reduct an image:\n* use photon_rs::conv::noise_reduction;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* noise_reduction(&mut img);\n* ```\n* Adds a constant to a select R, G, or B channel's value.\n* @param {PhotonImage} photon_image\n*/\nfunction noise_reduction(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.noise_reduction(photon_image.__wbg_ptr);\n}\n\n/**\n* Sharpen an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to sharpen an image:\n* use photon_rs::conv::sharpen;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* sharpen(&mut img);\n* ```\n* Adds a constant to a select R, G, or B channel's value.\n* @param {PhotonImage} photon_image\n*/\nfunction sharpen(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.sharpen(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply edge detection to an image, to create a dark version with its edges highlighted.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon_rs::conv::edge_detection;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* edge_detection(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction edge_detection(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.edge_detection(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply an identity kernel convolution to an image.\n*\n* # Arguments\n* * `img` -A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply an identity kernel convolution:\n* use photon_rs::conv::identity;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* identity(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction identity(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.identity(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply a box blur effect.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a box blur effect:\n* use photon_rs::conv::box_blur;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* box_blur(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction box_blur(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.box_blur(photon_image.__wbg_ptr);\n}\n\n/**\n* Gaussian blur in linear time.\n*\n* Reference: http://blog.ivank.net/fastest-gaussian-blur.html\n*\n* # Arguments\n* * `photon_image` - A PhotonImage\n* * `radius` - blur radius\n* # Example\n*\n* ```no_run\n* use photon_rs::conv::gaussian_blur;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* gaussian_blur(&mut img, 3_i32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} radius\n*/\nfunction gaussian_blur(photon_image, radius) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    _assertNum(radius);\n    wasm.gaussian_blur(photon_image.__wbg_ptr, radius);\n}\n\n/**\n* Detect horizontal lines in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to display the horizontal lines in an image:\n* use photon_rs::conv::detect_horizontal_lines;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* detect_horizontal_lines(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction detect_horizontal_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.detect_horizontal_lines(photon_image.__wbg_ptr);\n}\n\n/**\n* Detect vertical lines in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to display the vertical lines in an image:\n* use photon_rs::conv::detect_vertical_lines;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* detect_vertical_lines(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction detect_vertical_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.detect_vertical_lines(photon_image.__wbg_ptr);\n}\n\n/**\n* Detect lines at a forty five degree angle in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to display the lines at a forty five degree angle in an image:\n* use photon_rs::conv::detect_45_deg_lines;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* detect_45_deg_lines(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction detect_45_deg_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.detect_45_deg_lines(photon_image.__wbg_ptr);\n}\n\n/**\n* Detect lines at a 135 degree angle in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to display the lines at a 135 degree angle in an image:\n* use photon_rs::conv::detect_135_deg_lines;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* detect_135_deg_lines(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction detect_135_deg_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.detect_135_deg_lines(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply a standard laplace convolution.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a laplace effect:\n* use photon_rs::conv::laplace;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* laplace(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction laplace(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.laplace(photon_image.__wbg_ptr);\n}\n\n/**\n* Preset edge effect.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply this effect:\n* use photon_rs::conv::edge_one;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* edge_one(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction edge_one(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.edge_one(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply an emboss effect to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply an emboss effect:\n* use photon_rs::conv::emboss;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* emboss(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction emboss(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.emboss(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply a horizontal Sobel filter to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a horizontal Sobel filter:\n* use photon_rs::conv::sobel_horizontal;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* sobel_horizontal(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction sobel_horizontal(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.sobel_horizontal(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply a horizontal Prewitt convolution to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a horizontal Prewitt convolution effect:\n* use photon_rs::conv::prewitt_horizontal;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* prewitt_horizontal(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction prewitt_horizontal(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.prewitt_horizontal(photon_image.__wbg_ptr);\n}\n\n/**\n* Apply a vertical Sobel filter to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a vertical Sobel filter:\n* use photon_rs::conv::sobel_vertical;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* sobel_vertical(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nfunction sobel_vertical(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    if (photon_image.__wbg_ptr === 0) {\n        throw new Error('Attempt to use a moved value');\n    }\n    wasm.sobel_vertical(photon_image.__wbg_ptr);\n}\n\nfunction logError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        let error = (function () {\n            try {\n                return e instanceof Error ? `${e.message}\\n\\nStack:\\n${e.stack}` : e.toString();\n            } catch(_) {\n                return \"<failed to stringify thrown value>\";\n            }\n        }());\n        console.error(\"wasm-bindgen: imported JS function that was not marked as `catch` threw an error:\", error);\n        throw e;\n    }\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nlet cachedUint8ClampedMemory0 = null;\n\nfunction getUint8ClampedMemory0() {\n    if (cachedUint8ClampedMemory0 === null || cachedUint8ClampedMemory0.byteLength === 0) {\n        cachedUint8ClampedMemory0 = new Uint8ClampedArray(wasm.memory.buffer);\n    }\n    return cachedUint8ClampedMemory0;\n}\n\nfunction getClampedArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ClampedMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; }\n/**\n*/\nconst SamplingFilter = Object.freeze({ Nearest:1,\"1\":\"Nearest\",Triangle:2,\"2\":\"Triangle\",CatmullRom:3,\"3\":\"CatmullRom\",Gaussian:4,\"4\":\"Gaussian\",Lanczos3:5,\"5\":\"Lanczos3\", });\n/**\n* Provides the image's height, width, and contains the image's raw pixels.\n* For use when communicating between JS and WASM, and also natively.\n*/\nclass PhotonImage {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PhotonImage.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_photonimage_free(ptr);\n    }\n    /**\n    * Create a new PhotonImage from a Vec of u8s, which represent raw pixels.\n    * @param {Uint8Array} raw_pixels\n    * @param {number} width\n    * @param {number} height\n    */\n    constructor(raw_pixels, width, height) {\n        const ptr0 = passArray8ToWasm0(raw_pixels, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertNum(width);\n        _assertNum(height);\n        const ret = wasm.photonimage_new(ptr0, len0, width, height);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n    * Create a new PhotonImage from a base64 string.\n    * @param {string} base64\n    * @returns {PhotonImage}\n    */\n    static new_from_base64(base64) {\n        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.photonimage_new_from_base64(ptr0, len0);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n    * Create a new PhotonImage from a byteslice.\n    * @param {Uint8Array} vec\n    * @returns {PhotonImage}\n    */\n    static new_from_byteslice(vec) {\n        const ptr0 = passArray8ToWasm0(vec, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.photonimage_new_from_byteslice(ptr0, len0);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n    * Create a new PhotonImage from a Blob/File.\n    * @param {Blob} blob\n    * @returns {PhotonImage}\n    */\n    static new_from_blob(blob) {\n        const ret = wasm.photonimage_new_from_blob(addHeapObject(blob));\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n    * Create a new PhotonImage from a HTMLImageElement\n    * @param {HTMLImageElement} image\n    * @returns {PhotonImage}\n    */\n    static new_from_image(image) {\n        const ret = wasm.photonimage_new_from_image(addHeapObject(image));\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get_width() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.photonimage_get_width(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get the PhotonImage's pixels as a Vec of u8s.\n    * @returns {Uint8Array}\n    */\n    get_raw_pixels() {\n        try {\n            if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertNum(this.__wbg_ptr);\n            wasm.photonimage_get_raw_pixels(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the height of the PhotonImage.\n    * @returns {number}\n    */\n    get_height() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.photonimage_get_height(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Convert the PhotonImage to base64.\n    * @returns {string}\n    */\n    get_base64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertNum(this.__wbg_ptr);\n            wasm.photonimage_get_base64(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * Convert the PhotonImage to raw bytes. Returns PNG.\n    * @returns {Uint8Array}\n    */\n    get_bytes() {\n        try {\n            if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertNum(this.__wbg_ptr);\n            wasm.photonimage_get_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Convert the PhotonImage to raw bytes. Returns a JPEG.\n    * @param {number} quality\n    * @returns {Uint8Array}\n    */\n    get_bytes_jpeg(quality) {\n        try {\n            if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertNum(this.__wbg_ptr);\n            _assertNum(quality);\n            wasm.photonimage_get_bytes_jpeg(retptr, this.__wbg_ptr, quality);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Convert the PhotonImage to raw bytes. Returns a WEBP.\n    * @returns {Uint8Array}\n    */\n    get_bytes_webp() {\n        try {\n            if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertNum(this.__wbg_ptr);\n            wasm.photonimage_get_bytes_webp(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Convert the PhotonImage's raw pixels to JS-compatible ImageData.\n    * @returns {ImageData}\n    */\n    get_image_data() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.photonimage_get_image_data(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Convert ImageData to raw pixels, and update the PhotonImage's raw pixels to this.\n    * @param {ImageData} img_data\n    */\n    set_imgdata(img_data) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        wasm.photonimage_set_imgdata(this.__wbg_ptr, addHeapObject(img_data));\n    }\n}\n/**\n* RGB color type.\n*/\nclass Rgb {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Rgb.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rgb_free(ptr);\n    }\n    /**\n    * Create a new RGB struct.\n    * @param {number} r\n    * @param {number} g\n    * @param {number} b\n    */\n    constructor(r, g, b) {\n        _assertNum(r);\n        _assertNum(g);\n        _assertNum(b);\n        const ret = wasm.rgb_new(r, g, b);\n        return Rgb.__wrap(ret);\n    }\n    /**\n    * Set the Red value.\n    * @param {number} r\n    */\n    set_red(r) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        _assertNum(r);\n        wasm.rgb_set_red(this.__wbg_ptr, r);\n    }\n    /**\n    * Get the Green value.\n    * @param {number} g\n    */\n    set_green(g) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        _assertNum(g);\n        wasm.rgb_set_green(this.__wbg_ptr, g);\n    }\n    /**\n    * Set the Blue value.\n    * @param {number} b\n    */\n    set_blue(b) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        _assertNum(b);\n        wasm.rgb_set_blue(this.__wbg_ptr, b);\n    }\n    /**\n    * Get the Red value.\n    * @returns {number}\n    */\n    get_red() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.rgb_get_red(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Get the Green value.\n    * @returns {number}\n    */\n    get_green() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.rgb_get_green(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Get the Blue value.\n    * @returns {number}\n    */\n    get_blue() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.rgb_get_blue(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n* RGBA color type.\n*/\nclass Rgba {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Rgba.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rgba_free(ptr);\n    }\n    /**\n    * Create a new RGBA struct.\n    * @param {number} r\n    * @param {number} g\n    * @param {number} b\n    * @param {number} a\n    */\n    constructor(r, g, b, a) {\n        _assertNum(r);\n        _assertNum(g);\n        _assertNum(b);\n        _assertNum(a);\n        const ret = wasm.rgba_new(r, g, b, a);\n        return Rgba.__wrap(ret);\n    }\n    /**\n    * Set the Red value.\n    * @param {number} r\n    */\n    set_red(r) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        _assertNum(r);\n        wasm.rgba_set_red(this.__wbg_ptr, r);\n    }\n    /**\n    * Get the Green value.\n    * @param {number} g\n    */\n    set_green(g) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        _assertNum(g);\n        wasm.rgba_set_green(this.__wbg_ptr, g);\n    }\n    /**\n    * Set the Blue value.\n    * @param {number} b\n    */\n    set_blue(b) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        _assertNum(b);\n        wasm.rgba_set_blue(this.__wbg_ptr, b);\n    }\n    /**\n    * Set the alpha value.\n    * @param {number} a\n    */\n    set_alpha(a) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        _assertNum(a);\n        wasm.rgba_set_alpha(this.__wbg_ptr, a);\n    }\n    /**\n    * Get the Red value.\n    * @returns {number}\n    */\n    get_red() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.rgba_get_red(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Get the Green value.\n    * @returns {number}\n    */\n    get_green() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.rgba_get_green(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Get the Blue value.\n    * @returns {number}\n    */\n    get_blue() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.rgba_get_blue(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Get the alpha value for this color.\n    * @returns {number}\n    */\n    get_alpha() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ret = wasm.rgba_get_alpha(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nfunction __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nfunction __wbg_error_f851667af71bcfc6() { return logError(function (arg0, arg1) {\n    let deferred0_0;\n    let deferred0_1;\n    try {\n        deferred0_0 = arg0;\n        deferred0_1 = arg1;\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(deferred0_0, deferred0_1);\n    }\n}, arguments) };\n\nfunction __wbg_new_abda76e883ba8a5f() { return logError(function () {\n    const ret = new Error();\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_stack_658279fe44541cf6() { return logError(function (arg0, arg1) {\n    const ret = getObject(arg1).stack;\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n}, arguments) };\n\nfunction __wbg_instanceof_Window_f2bf9e8e91f1be0d() { return logError(function (arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof Window;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    _assertBoolean(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_document_a11e2f345af07033() { return logError(function (arg0) {\n    const ret = getObject(arg0).document;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_body_483afe07b0958d3b() { return logError(function (arg0) {\n    const ret = getObject(arg0).body;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_createElement_5281e2aae74efc9d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_instanceof_CanvasRenderingContext2d_b4050f3a451ac712() { return logError(function (arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof CanvasRenderingContext2D;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    _assertBoolean(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_drawImage_fa7fd856fb164132() { return handleError(function (arg0, arg1, arg2, arg3) {\n    getObject(arg0).drawImage(getObject(arg1), arg2, arg3);\n}, arguments) };\n\nfunction __wbg_drawImage_41f8e8a7fc2b0de3() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {\n    getObject(arg0).drawImage(getObject(arg1), arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n}, arguments) };\n\nfunction __wbg_getImageData_956c421f9b7cdfe7() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).getImageData(arg1, arg2, arg3, arg4);\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_putImageData_0009acf77045dec6() { return handleError(function (arg0, arg1, arg2, arg3) {\n    getObject(arg0).putImageData(getObject(arg1), arg2, arg3);\n}, arguments) };\n\nfunction __wbg_width_250e8da00ab1c884() { return logError(function (arg0) {\n    const ret = getObject(arg0).width;\n    _assertNum(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_height_e41b71b2f3141e8e() { return logError(function (arg0) {\n    const ret = getObject(arg0).height;\n    _assertNum(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_width_020d7bde350571e9() { return logError(function (arg0) {\n    const ret = getObject(arg0).width;\n    _assertNum(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_height_d65d28af1b6f26d3() { return logError(function (arg0) {\n    const ret = getObject(arg0).height;\n    _assertNum(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_data_f319d3380b214a26() { return logError(function (arg0, arg1) {\n    const ret = getObject(arg1).data;\n    const ptr1 = passArray8ToWasm0(ret, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n}, arguments) };\n\nfunction __wbg_newwithu8clampedarrayandsh_c90e0c3609c4ecc2() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = new ImageData(getClampedArrayU8FromWasm0(arg0, arg1), arg2 >>> 0, arg3 >>> 0);\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_instanceof_HtmlCanvasElement_6e58598b4e8b1586() { return logError(function (arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof HTMLCanvasElement;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    _assertBoolean(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_width_3a395887a577233b() { return logError(function (arg0) {\n    const ret = getObject(arg0).width;\n    _assertNum(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_setwidth_885d5dd3c7f48f41() { return logError(function (arg0, arg1) {\n    getObject(arg0).width = arg1 >>> 0;\n}, arguments) };\n\nfunction __wbg_height_b7046017c4148386() { return logError(function (arg0) {\n    const ret = getObject(arg0).height;\n    _assertNum(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_setheight_0d2b445bb6a5a3f2() { return logError(function (arg0, arg1) {\n    getObject(arg0).height = arg1 >>> 0;\n}, arguments) };\n\nfunction __wbg_getContext_62ccb1aa0e6c8b86() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).getContext(getStringFromWasm0(arg1, arg2));\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_settextContent_ea2ce5e8fc889af7() { return logError(function (arg0, arg1, arg2) {\n    getObject(arg0).textContent = arg1 === 0 ? undefined : getStringFromWasm0(arg1, arg2);\n}, arguments) };\n\nfunction __wbg_appendChild_173b88a25c048f2b() { return handleError(function (arg0, arg1) {\n    const ret = getObject(arg0).appendChild(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_newnoargs_e643855c6572a4a8() { return logError(function (arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_call_f96b398515635514() { return handleError(function (arg0, arg1) {\n    const ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_globalThis_d0957e302752547e() { return handleError(function () {\n    const ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_self_b9aad7f1c618bfaf() { return handleError(function () {\n    const ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_window_55e469842c98b086() { return handleError(function () {\n    const ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_global_ae2f87312b8987fb() { return handleError(function () {\n    const ret = __webpack_require__.g.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_new_bc5d9aad3f9ac80e() { return logError(function (arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_length_d9c4ded7e708c6a1() { return logError(function (arg0) {\n    const ret = getObject(arg0).length;\n    _assertNum(ret);\n    return ret;\n}, arguments) };\n\nfunction __wbg_set_4b3aa8445ac1e91c() { return logError(function (arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n}, arguments) };\n\nconst __wbg_random_f67f027fd89c6d9c = typeof Math.random == 'function' ? Math.random : notDefined('Math.random');\n\nfunction __wbindgen_is_undefined(arg0) {\n    const ret = getObject(arg0) === undefined;\n    _assertBoolean(ret);\n    return ret;\n};\n\nfunction __wbindgen_object_clone_ref(arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_buffer_fcbfb6d88b2732e9() { return logError(function (arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbindgen_debug_string(arg0, arg1) {\n    const ret = debugString(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nfunction __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n\n\n//# sourceURL=webpack://photon-wasm/../crate/pkg/photon_rs_bg.js?");

/***/ }),

/***/ "../crate/pkg/photon_rs_bg.wasm":
/*!**************************************!*\
  !*** ../crate/pkg/photon_rs_bg.wasm ***!
  \**************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./photon_rs_bg.js */ \"../crate/pkg/photon_rs_bg.js\");\nmodule.exports = __webpack_require__.v(exports, module.id, \"66d531fb4651c57454ae\", {\n\t\"./photon_rs_bg.js\": {\n\t\t\"__wbindgen_object_drop_ref\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_drop_ref,\n\t\t\"__wbg_error_f851667af71bcfc6\": WEBPACK_IMPORTED_MODULE_0.__wbg_error_f851667af71bcfc6,\n\t\t\"__wbg_new_abda76e883ba8a5f\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_abda76e883ba8a5f,\n\t\t\"__wbg_stack_658279fe44541cf6\": WEBPACK_IMPORTED_MODULE_0.__wbg_stack_658279fe44541cf6,\n\t\t\"__wbg_instanceof_Window_f2bf9e8e91f1be0d\": WEBPACK_IMPORTED_MODULE_0.__wbg_instanceof_Window_f2bf9e8e91f1be0d,\n\t\t\"__wbg_document_a11e2f345af07033\": WEBPACK_IMPORTED_MODULE_0.__wbg_document_a11e2f345af07033,\n\t\t\"__wbg_body_483afe07b0958d3b\": WEBPACK_IMPORTED_MODULE_0.__wbg_body_483afe07b0958d3b,\n\t\t\"__wbg_createElement_5281e2aae74efc9d\": WEBPACK_IMPORTED_MODULE_0.__wbg_createElement_5281e2aae74efc9d,\n\t\t\"__wbg_instanceof_CanvasRenderingContext2d_b4050f3a451ac712\": WEBPACK_IMPORTED_MODULE_0.__wbg_instanceof_CanvasRenderingContext2d_b4050f3a451ac712,\n\t\t\"__wbg_drawImage_fa7fd856fb164132\": WEBPACK_IMPORTED_MODULE_0.__wbg_drawImage_fa7fd856fb164132,\n\t\t\"__wbg_drawImage_41f8e8a7fc2b0de3\": WEBPACK_IMPORTED_MODULE_0.__wbg_drawImage_41f8e8a7fc2b0de3,\n\t\t\"__wbg_getImageData_956c421f9b7cdfe7\": WEBPACK_IMPORTED_MODULE_0.__wbg_getImageData_956c421f9b7cdfe7,\n\t\t\"__wbg_putImageData_0009acf77045dec6\": WEBPACK_IMPORTED_MODULE_0.__wbg_putImageData_0009acf77045dec6,\n\t\t\"__wbg_width_250e8da00ab1c884\": WEBPACK_IMPORTED_MODULE_0.__wbg_width_250e8da00ab1c884,\n\t\t\"__wbg_height_e41b71b2f3141e8e\": WEBPACK_IMPORTED_MODULE_0.__wbg_height_e41b71b2f3141e8e,\n\t\t\"__wbg_width_020d7bde350571e9\": WEBPACK_IMPORTED_MODULE_0.__wbg_width_020d7bde350571e9,\n\t\t\"__wbg_height_d65d28af1b6f26d3\": WEBPACK_IMPORTED_MODULE_0.__wbg_height_d65d28af1b6f26d3,\n\t\t\"__wbg_data_f319d3380b214a26\": WEBPACK_IMPORTED_MODULE_0.__wbg_data_f319d3380b214a26,\n\t\t\"__wbg_newwithu8clampedarrayandsh_c90e0c3609c4ecc2\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithu8clampedarrayandsh_c90e0c3609c4ecc2,\n\t\t\"__wbg_instanceof_HtmlCanvasElement_6e58598b4e8b1586\": WEBPACK_IMPORTED_MODULE_0.__wbg_instanceof_HtmlCanvasElement_6e58598b4e8b1586,\n\t\t\"__wbg_width_3a395887a577233b\": WEBPACK_IMPORTED_MODULE_0.__wbg_width_3a395887a577233b,\n\t\t\"__wbg_setwidth_885d5dd3c7f48f41\": WEBPACK_IMPORTED_MODULE_0.__wbg_setwidth_885d5dd3c7f48f41,\n\t\t\"__wbg_height_b7046017c4148386\": WEBPACK_IMPORTED_MODULE_0.__wbg_height_b7046017c4148386,\n\t\t\"__wbg_setheight_0d2b445bb6a5a3f2\": WEBPACK_IMPORTED_MODULE_0.__wbg_setheight_0d2b445bb6a5a3f2,\n\t\t\"__wbg_getContext_62ccb1aa0e6c8b86\": WEBPACK_IMPORTED_MODULE_0.__wbg_getContext_62ccb1aa0e6c8b86,\n\t\t\"__wbg_settextContent_ea2ce5e8fc889af7\": WEBPACK_IMPORTED_MODULE_0.__wbg_settextContent_ea2ce5e8fc889af7,\n\t\t\"__wbg_appendChild_173b88a25c048f2b\": WEBPACK_IMPORTED_MODULE_0.__wbg_appendChild_173b88a25c048f2b,\n\t\t\"__wbg_newnoargs_e643855c6572a4a8\": WEBPACK_IMPORTED_MODULE_0.__wbg_newnoargs_e643855c6572a4a8,\n\t\t\"__wbg_call_f96b398515635514\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_f96b398515635514,\n\t\t\"__wbg_globalThis_d0957e302752547e\": WEBPACK_IMPORTED_MODULE_0.__wbg_globalThis_d0957e302752547e,\n\t\t\"__wbg_self_b9aad7f1c618bfaf\": WEBPACK_IMPORTED_MODULE_0.__wbg_self_b9aad7f1c618bfaf,\n\t\t\"__wbg_window_55e469842c98b086\": WEBPACK_IMPORTED_MODULE_0.__wbg_window_55e469842c98b086,\n\t\t\"__wbg_global_ae2f87312b8987fb\": WEBPACK_IMPORTED_MODULE_0.__wbg_global_ae2f87312b8987fb,\n\t\t\"__wbg_new_bc5d9aad3f9ac80e\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_bc5d9aad3f9ac80e,\n\t\t\"__wbg_length_d9c4ded7e708c6a1\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_d9c4ded7e708c6a1,\n\t\t\"__wbg_set_4b3aa8445ac1e91c\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_4b3aa8445ac1e91c,\n\t\t\"__wbg_random_f67f027fd89c6d9c\": WEBPACK_IMPORTED_MODULE_0.__wbg_random_f67f027fd89c6d9c,\n\t\t\"__wbindgen_is_undefined\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_undefined,\n\t\t\"__wbindgen_object_clone_ref\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_clone_ref,\n\t\t\"__wbg_buffer_fcbfb6d88b2732e9\": WEBPACK_IMPORTED_MODULE_0.__wbg_buffer_fcbfb6d88b2732e9,\n\t\t\"__wbindgen_debug_string\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_debug_string,\n\t\t\"__wbindgen_throw\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,\n\t\t\"__wbindgen_memory\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_memory\n\t}\n});\n\n//# sourceURL=webpack://photon-wasm/../crate/pkg/photon_rs_bg.wasm?");

/***/ })

}]);